# -*- coding: utf-8 -*-
"""
Created on Wed Jan  9 16:23:44 2019
@author: Ocean Insight Inc.
"""
import traceback
import json
from typing import List
from ctypes import cdll, c_int, c_ushort, c_uint, c_long, create_string_buffer, c_ulong, c_ubyte, c_double, c_float, c_longlong, POINTER, byref
from enum import Enum,auto
from oceandirect.sdk_properties import oceandirect_dll
from oceandirect.od_logger import od_logger

logger = od_logger()

class OceanDirectError(Exception):
    """!
    An error code and error message object wrapper.
    """

    def __init__(self, errorCode: int, errorMsg: str):
        super(OceanDirectError, self).__init__(errorMsg)
        self._error_code = errorCode
        self._error_msg  = errorMsg

    def get_error_details(self) -> tuple[int, str]:
        return (self._error_code, self._error_msg)

class OceanDirectAPI:
    
    class __OceanDirectSingleton:
        def __init__(self):
            self.oceandirect = cdll.LoadLibrary(oceandirect_dll)
            self.oceandirect.odapi_initialize()
            self.open_devices = dict()
            self.num_devices  = 0
            self.usb_devices  = 0

        def __del__(self):
            """
            Closes all open devices and the odapi singleton.
            """
            try:
                self.close_all_devices()
                self.shutdown()
            except Exception as e:
                exe_msg = traceback.format_exc()
                sdk_data_json = json.dumps(exe_msg)
                logger.error(sdk_data_json)
            
        def close_all_devices(self) -> None:
            """
            Closes all opened devices.
            """
            for dev in self.open_devices:
                self.open_devices[dev].close_device()
        
        def shutdown(self) -> None:
            """
            Release any remaining used resources before shutting down the program.
            """
            self.oceandirect.odapi_shutdown()

    instance = None

    def __init__(self):
        """
        Loads and initializes the OceanDirect dll and initializes internal variables.
        """

        if not OceanDirectAPI.instance:
            OceanDirectAPI.instance = OceanDirectAPI.__OceanDirectSingleton()
        
    def __getattr__(self, name):
        return getattr(self.instance, name)
    
    def decode_error(self, errno: int, caller: str) -> str:
        """
        OceanDirectAPI returns an error code if something goes wrong. This function will decode
        that error to a readable string.
        @param errno: The error code generated by OceanDirect api.
        :type errno: int
        @param caller: The caller which produces the error code. Use for debugging purposes only.
        :type caller: str
        """

        error_str_len = self.oceandirect.odapi_get_error_string_length(errno)
        errstr_cp     = create_string_buffer(b'\000'*error_str_len)
        self.oceandirect.odapi_get_error_string(errno, errstr_cp, error_str_len)
        errstr = ("%s errcode(%d): %s" % (caller, errno, errstr_cp.value.decode()))
        #logger.error(errstr)
#        logger.error("%s errcode(%d): %s" % (caller, errno, errstr_cp.value.decode()))
#        return errstr_cp.value.decode()
        return errstr

    def get_api_version_numbers(self) -> tuple[int, int, int]:
        """!
        Return OceanDirect api version information.
        @return An integer tuple of major, minor, and point value.
        """

        major = c_uint(0)
        minor = c_uint(0)
        point = c_uint(0)

        self.oceandirect.odapi_get_api_version_numbers.argtypes = [POINTER(c_uint), POINTER(c_uint), POINTER(c_uint)]
        self.oceandirect.odapi_get_api_version_numbers(byref(major), byref(minor), byref(point) )

        return (major.value, minor.value, point.value)

    def open_device(self, device_id: int) -> 'Spectrometer':
        """!
        Attach to a device discovered by probe_devices or get_device_ids. It also saves it to a map
        keyed off of the device id. After the device is closed the device_id becomes invalid. You need to 
        call either find_devices()/find_usb_devices()/add_network_device() and get_device_ids() in order 
        to have a valid id before reopening the device again. Note that this should only be done by
        one thread at a time. For multithreaded application this function must be synchronized.
        @param[in] device_id  The device id.
        @return The device object.
        @see find_devices()
        @see find_usb_devices()
        @see add_network_device()
        """

        if device_id in self.open_devices:
            device = self.open_devices[device_id]
            device.open_device()
        else:
            device = Spectrometer(device_id, self.oceandirect)
            device.open_device()
            self.open_devices[device_id] = device
        return device

    def add_network_device(self, ipAddressStr: str, deviceTypeStr: str) -> None:
        """!
        Manually create an instance of the network attached device and then open it using 
        the openDevice() function. It is the responsiblitiy of the user to ensure that 
        the device exist and configured properly. Note that this should only be done by one thread
        at a time. For multithreaded application this function must be synchronized.
        @param[in] ipAddressStr   The ip address of the device to be opened.
        @param[in] deviceTypeStr  The device type could be OceanFX or OceanHDX. This is case sensitive.
        """

        if not ipAddressStr or not deviceTypeStr:
            error_msg = self.decode_error(15, "add_network_device")
            raise OceanDirectError(15, error_msg)

        err_cp  = (c_long * 1)(0)
        self.oceandirect.odapi_add_network_devices(ipAddressStr.encode('utf-8'), deviceTypeStr.encode('utf-8'), err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "add_network_device")
            raise OceanDirectError(err_cp[0], error_msg)

    def close_device(self, device_id: int) -> None:
        """!
        Detach from the device indicated by device_id. This persists the device for later use. The device_id becomes 
        invalid after closing the device. Note that this should only be done by one thread at a time.
        For multithreaded application this function must be synchronized.
        @param[in] device_id  The id of the device to be closed.
        @see open_device()
        """

        if device_id in self.open_devices:
            device = self.open_devices[device_id]
            device.close_device()

    def list_all_devices(self) -> None:
        """!
        Lists defined details of all active devices.
        """
        for dev in self.open_devices:
            self.open_devices[dev].details()
       
    def shutdown(self) -> None:
        """!
        Closes the connection to OceanDirectAPI. This is the last to be called before the program terminates.
        """
        self.oceandirect.odapi_shutdown()

    def find_devices(self) -> int:
        """!
        Finds all available Ocean devices by scanning on USB for devices with Ocean drivers, finding
        devices that respond to UDP multicast (FX and HDX), and also returning IDs for any TCP-enabled
        devices that have been manually specified using addTCPDeviceLocation(). Note that this should 
        only be done by one thread at a time. For multithreaded application this function must be synchronized.
        @return Number of devices found.
        @see open_device()
        """

        try:
            self.tcpip_devices = self.oceandirect.odapi_detect_network_devices()
        except Exception as e:
            exe_msg = traceback.format_exc()
            sdk_data_json = json.dumps(exe_msg)
            logger.error(sdk_data_json)

        try:
            self.usb_devices = self.oceandirect.odapi_probe_devices()
        except Exception as e:
            exe_msg = traceback.format_exc()
            sdk_data_json = json.dumps(exe_msg)
            logger.error(sdk_data_json)

        totalDevicesFound = 0
        try:
            totalDevicesFound = self.oceandirect.odapi_get_number_of_device_ids()
        except OceanDirectError as err:
            exe_msg = traceback.format_exc()
            sdk_data_json = json.dumps(exe_msg)
            logger.error(sdk_data_json)

        return totalDevicesFound

    def find_usb_devices(self) -> int:
        """!
        Finds all available Ocean devices by scanning on USB for devices with Ocean drivers. Note that 
        this should only be done by one thread at a time. For multithreaded application this function
        must be synchronized.
        @return Number of devices found.
        @see open_device()
        """

        try:
            self.usb_devices = self.oceandirect.odapi_probe_devices()
        except Exception as e:
            exe_msg = traceback.format_exc()
            sdk_data_json = json.dumps(exe_msg)
            logger.error(sdk_data_json)
        return self.usb_devices

    def add_network_device(self, ipAddress: str, deviceType: str) -> int:
        """!
        Manually create an instance of the network attached device and then open it using the openDevice() function. It 
        is the responsiblitiy of the user to ensure that the device exist and configured properly. Note that this
        should only be done by one thread at a time.
        @param[in] ipAddress The ip address as string (ex: "10.20.30.100" ) of the device to be opened.
        @param[in] deviceType The device type could be OceanFX or OceanHDX. This is case sensitive.
        @return The device id.
        @see open_device()
        """

        deviceId = -1
        err_cp   = (c_long * 1)(0)

        if not ipAddress or not deviceType:
            #15 is an error code defined in OceanDirectAPIConstants.c
            error_msg = self.decode_error(15, "add_network_device")
            raise OceanDirectError(15, error_msg)

        try:
            deviceId = self.oceandirect.odapi_add_network_devices(ipAddress.encode('utf-8'), deviceType.encode('utf-8'), err_cp)
        except Exception as e:
            exe_msg = traceback.format_exc()
            sdk_data_json = json.dumps(exe_msg)
            logger.error(sdk_data_json)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"add_network_device")
            raise OceanDirectError(err_cp[0], error_msg)

        return deviceId

    def get_number_devices(self) -> int:
        """!
        Returns the number of devices available. Note that this should only be done by 
        one thread at a time.
        @return The number of connected(discovered) devices.
        """

        try:
            self.num_devices = self.oceandirect.odapi_get_number_of_device_ids()
        except Exception as e:
            exe_msg = traceback.format_exc()
            sdk_data_json = json.dumps(exe_msg)
            logger.error(sdk_data_json)   
    
        return self.num_devices

    def get_device_ids(self) -> list[int]:
        """!
        Return a list of device ids from devices that were both probe or manually added. Note that
        this should only be done by one thread at a time. For multithreaded application this
        function must be synchronized.
        @return List of device id's.
        """

        #probed  = self.probe_devices(devtype)
        num_ids = self.get_number_devices()
        ids_cp = (c_long * num_ids)()
        err_cp = (c_long * 1)()
        n      = self.oceandirect.odapi_get_device_ids(ids_cp, err_cp)

        if n > 0:
            self.device_ids = list(ids_cp)
        else:
            self.device_ids =list()
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_device_ids")
            raise OceanDirectError(err_cp[0], error_msg)

        return self.device_ids

    def get_network_device_ids(self) -> list[int]:
        """!
        Return a list of network device ids from devices that were probe. Note that
        this should only be done by one thread at a time. For multithreaded application 
        this function must be synchronized.
        @return List of network device id's.
        """

        #probed  = self.probe_devices(devtype)
        num_ids = self.get_number_devices()
        ids_cp = (c_long * num_ids)()
        err_cp = (c_long * 1)()
        n      = self.oceandirect.odapi_get_network_device_ids(ids_cp, err_cp)
        networkIds = list()
        if n > 0:
            for i in range(n):
                networkIds.append(int(ids_cp[i]))
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_network_device_ids")
            raise OceanDirectError(err_cp[0], error_msg)

        return networkIds

    def from_serial_number(self, serial_num: str) -> 'Spectrometer':
        """!
        Return a spectrometer object associated with device id. User should not call this function. This function is
        used internally in OceanDirect.
        @param[in] serial_num The device serial number.
        @return The spectrometer object if found, None otherwise.
        """

        devids = self.get_device_ids()
        dev    = None

        if len(devids) > 0:
            for dev_id in devids:
                dev = self.open_device(dev_id)
                od_status = dev.status 
                sn = self.get_serial_number(dev_id)
                if sn == serial_num:
                    break
                if (od_status == 'closed'):
                    self.close_device(dev_id)
        return dev
     
    def add_rs232_device(self, device_type: str, bus_path: str, baud: int) -> None:
        """!
        Adds a device connected via RS 232 to the device list. Untested.
        @param[in] device_type  The name of a type of device. This can be one of the following: QE-PRO, STS.
        @param[in] bus_path     The location of the device on the RS232 bus. This will be a platform-specific
                                location. Under Windows, this may be COM1, COM2, etc. Under Linux, this might
                                be /dev/ttyS0, /dev/ttyS1,
        @param[in] baud         The baud rate. See device manual for supported baud rate.
        """

        dev_type_cp = create_string_buffer(str.encode(device_type), len(device_type))
        bus_path_cp = create_string_buffer(str.encode(bus_path), len(bus_path))
        added       = self.oceandirect.odapi_add_RS232_device_location(dev_type_cp, bus_path_cp, baud)

        if added != 0:
            error_msg = self.decode_error(added, "add_rs232_device")
            raise OceanDirectError(self.err_cp[0], error_msg)
        logger.info("Add for %s at bus path %s  result %d" %  (device_type, bus_path, added))

    def get_serial_number(self, dev_id: int) -> str:
        """!
        Gets the serial number of a specified device. This is used internally to find the desired device.
        @param[in] dev_id  The id of a device.
        @return The device serial number if found, None otherwise.
        """

        serial_number = None
        if dev_id in self.open_devices:
            serial_number = self.open_devices[dev_id].serial_number
        if serial_number is None:
            serial_cp = create_string_buffer(b'\000'*32)
            err_cp = (c_long * 1)()
            self.oceandirect.odapi_get_serial_number(dev_id, err_cp, serial_cp, 32)
            if err_cp[0] != 0:
                error_msg = self.decode_error(err_cp[0], "get_serial_number")
                raise OceanDirectError(err_cp[0], error_msg)
            serial_number = serial_cp.value
        return serial_number


class FeatureID(Enum):
    """!
    An enumerated class for feature id. Use the method "is_feature_id()" and the id's below to check
    if a feature is supported by the device or not.
    NOTE:
    Do not change the values and order below without synchronizing the changes from the C files.
    """
    SERIAL_NUMBER = 1
    SPECTROMETER = auto()
    THERMOELECTRIC = auto()
    IRRADIANCE_CAL = auto()
    EEPROM = auto()
    STROBE_LAMP = auto()
    WAVELENGTH_CAL = auto()
    NONLINEARITY_CAL = auto()
    STRAYLIGHT_CAL = auto()
    RAW_BUS_ACCESS = auto()
    CONTINUOUS_STROBE = auto()
    LIGHT_SOURCE = auto()
    TEMPERATURE = auto()
    OPTICAL_BENCH = auto()
    REVISION = auto()
    PROCESSING = auto()
    DATA_BUFFER = auto()
    ACQUISITION_DELAY = auto()
    PIXEL_BINNING = auto()
    GPIO = auto()
    SINGLE_STROBE = auto()
    QUERY_STATUS = auto()
    BACK_TO_BACK = auto()
    LED_ACTIVITY = auto()
    TIME_META = auto()
    DHCP = auto()
    #SHUTTER = auto()
    IPV4_ADDRESS = auto()
    PIXEL = auto()
    AUTO_NULLING = auto()
    USER_STRING = auto()
    DEVICE_INFORMATION = auto()
    DEVICE_ALIAS = auto()
    SERIAL_PORT = auto()
    SPECTRUM_ACQUISITION_CONTROL = auto()
    NETWORK_CONFIGURATION = auto()
    ETHERNET = auto()
    SHUTTER = auto()
    HIGH_GAIN_MODE = auto()

    @classmethod
    def from_param(cls, obj):
        if not isinstance(obj, FeatureID):
            raise TypeError('not a FeatureID enumeration')
        return c_int32(obj.value)


class Spectrometer():
    """!
    Class that models the individual spectrometer. Should be created by OceanDirectAPI instance. This
    has an inner class called "Advanced" that contains functions to access other features of the device.
    """

    def __init__(self, dev_id: int, oceandirect):
        self.device_id = dev_id
        self.serial_number = None
        self.model = None
        self.model_name = None
        self.integration_time = None
        self.integration_min = None
        self.integration_max = None
        self.pixel_count_formatted = 0
        self.num_electric_dark_pixels = None
        self.electric_dark_pixels = list()
        self.status = 'closed'
        self.wavelengths = None
        self.oceandirect = oceandirect
        self.Advanced = self.Advanced(device = self)
        self.apply_nonlinearity = True
        self.scans_to_avg = 1
        self.boxcar_hw = False
        self.__nlflag = c_ubyte(1)

    def get_serial_number(self) -> str:
        """!
        Read the device serial number.
        @return The serial number.
        """

        serial_cp = create_string_buffer(b'\000'*32)
        err_cp    = (c_long * 1)(0)
        self.oceandirect.odapi_get_serial_number(self.device_id, err_cp, serial_cp, 32)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_serial_number")
            raise OceanDirectError(err_cp[0], error_msg)
    
        self.serial_number = serial_cp.value.decode()
        return self.serial_number

    def get_device_type(self) -> int:
        """!
        Read the device type.
        @return The device type.
        """

        device_type = create_string_buffer(b'\000' * 32)
        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_get_device_type(self.device_id, err_cp, device_type, 32)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_device_type")
            raise OceanDirectError(err_cp[0], error_msg)

        return device_type.value.decode()

    def get_model(self) -> str:
        """!
        Read the correct spectrometer model name assigned.
        @return The device model name.
        """

        model_cp = create_string_buffer(b'\000'*32)
        err_cp   = (c_long * 1)(0)
        self.oceandirect.odapi_get_device_name(self.device_id, err_cp, model_cp, 32)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_model")
            raise OceanDirectError(err_cp[0], error_msg)
        
        self.model_name = model_cp.value.decode()
        return self.model_name

    def decode_error(self, errno: int, caller: str) -> str:
        """!
        Decodes the error string returned from device calls.
        @param[in] errno  The error code.
        @param[in] caller The method name that calls this function.
        @return The string description of the error code.
        """

        error_str_len = self.oceandirect.odapi_get_error_string_length(errno)
        errstr_cp = create_string_buffer(b'\000'*error_str_len)
        self.oceandirect.odapi_get_error_string(errno, errstr_cp, error_str_len)
        #logger.error("%s errno(%d): %s" % (caller, errno, errstr_cp.value.decode()))
        return errstr_cp.value.decode()
    
    def open_device(self) -> None:
        """!
        Open the current device associated with this spectrometer object.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_open_device(self.device_id, err_cp)

        if err_cp[0] != 0:
            #logger.error("open_device %s" % self.decode_error(err_cp[0], "open_device"))
            error_msg = self.decode_error(err_cp[0],"open_device")
            raise OceanDirectError(err_cp[0], error_msg)
        else:
            self.status = 'open'
            err_cp = (c_long * 1)(0)
            self.pixel_count_formatted = self.oceandirect.odapi_get_formatted_spectrum_length(self.device_id, err_cp)
            if err_cp[0] != 0:
                error_msg = self.decode_error(err_cp[0], "get_formatted_spectrum_length")
                raise OceanDirectError(err_cp[0], error_msg)
            if self.serial_number is None:
                self.serial_number = self.get_serial_number()
            self.get_wavelengths()

    def close_device(self) -> None:
        """!
        Detaches the device to free it up for other users. This function must be called when you're done using the device.
        """

        err_cp = (c_long * 1)(0)
        if self.status == 'open':
            self.oceandirect.odapi_close_device(self.device_id, err_cp)
            if err_cp[0] != 0:
                error_msg = self.decode_error(err_cp[0],"close_device")
                raise OceanDirectError(err_cp[0], error_msg)
        self.status = 'closed'

    def use_nonlinearity(self, nonlinearity_flag: bool) -> None:
        """!
        Determine if nonlinearity correction should be used in calculations. Typically should be set to true.
        @param[in] nonlinearity_flag True to enable nonlinearity correction otherwise it's False.
        """

        self.apply_nonlinearity = nonlinearity_flag
        if nonlinearity_flag:
            self.__nlflag = c_ubyte(1)
        else:
            self.__nlflag = c_ubyte(0)

    def set_scans_to_average(self, newScanToAverage: int) -> None:
        """!
        Sets the number of spectra to average. 
        @param[in] newScanToAverage The number of spectra to average.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_set_scans_to_average(self.device_id, err_cp, newScanToAverage)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "set_scans_to_average")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_scans_to_average(self) -> int:
        """!
        Gets the number of spectra to average.
        @return The number of spectra to average.
        """

        err_cp = (c_long * 1)(0)
        scanToAverage = self.oceandirect.odapi_get_scans_to_average(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_scans_to_average")
            raise OceanDirectError(err_cp[0], error_msg)

        return scanToAverage

    def set_boxcar_width(self, newBoxcarWidth: int) -> None:
        """!
        Sets the boxcar width to average the spectral data.
        @param[in] newBoxcarWidth The boxcar width.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_set_boxcar_width(self.device_id, err_cp, newBoxcarWidth)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "set_boxcar_width")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_boxcar_width(self) -> int:
        """!
        Read the current boxcar width setting.
        @return The boxcar width.
        """

        err_cp = (c_long * 1)(0)
        boxcarWidth = self.oceandirect.odapi_get_boxcar_width(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_boxcar_width")
            raise OceanDirectError(err_cp[0], error_msg)

        return boxcarWidth

    def get_max_intensity(self) -> int:
        """!
        Returns the maximum pixel value the detector can read.
        @return The maximum intensity.
        """

        self.oceandirect.odapi_get_maximum_intensity.restype = c_double
        err_cp        = (c_long * 1)(0)
        max_intensity = self.oceandirect.odapi_get_maximum_intensity(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "max_intensity")
            raise OceanDirectError(err_cp[0], error_msg)
        return max_intensity

    def get_formatted_spectrum(self) -> list[float]:
        """!
        Return a formatted spectrum.
        @return The formatted spectrum.
        """

        spd_c = (c_double * self.pixel_count_formatted)()
        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_get_formatted_spectrum(self.device_id, err_cp, spd_c, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_formatted_spectrum")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(spd_c)

    def get_formatted_spectrum_length(self) -> int:
        """!
        Return the formatted spectra length.
        @return The spectra length.
        """

        return self.pixel_count_formatted

    def get_wavelengths(self) -> list[float]:
        """!
        This computes the wavelengths for the spectrometer and fills in the
	    provided array (up to the given length) with those values.
        @return The wavelength values for the device in a python list.
        """

        if self.wavelengths is None:
            wl_c   = (c_double * self.pixel_count_formatted)()
            err_cp = (c_long * 1)(0)
            buffer_size = self.oceandirect.odapi_get_wavelengths(self.device_id, err_cp, wl_c, self.pixel_count_formatted)
            #logger.info("Buffer size returned: %d  expected %d " % (buffer_size, self.pixel_count_formatted))
            if err_cp[0] != 0:
                error_msg = self.decode_error(err_cp[0],"get_wavelengths")
                raise OceanDirectError(err_cp[0], error_msg)
            else:
                self.wavelengths = list(wl_c)
        return self.wavelengths
    
    def get_minimum_integration_time(self) -> int:
        """!
        Returns the minimum allowable integration time on the device.
        @return The minimum integration time.
        """

        err_cp       = (c_long * 1)(0)
        int_time_min = self.oceandirect.odapi_get_minimum_integration_time_micros(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_minimum_integration_time")
            raise OceanDirectError(err_cp[0], error_msg)
        self.integration_min = int_time_min
        return self.integration_min
    
    def get_maximum_integration_time(self) -> int:
        """!
        Returns the maximum allowable integration time on the device.
        @return The maximum integration time.
        """

        err_cp       = (c_long * 1)(0)
        int_time_max = self.oceandirect.odapi_get_maximum_integration_time_micros(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_maximum_integration_time")
            raise OceanDirectError(err_cp[0], error_msg)
        self.integration_max = int_time_max
        return self.integration_max
 
    def get_minimum_averaging_integration_time(self) -> int:
        """!
        This function returns the smallest integration time setting, in microseconds, that is valid for the spectrometer.
        NOTE: some devices that make use of onboard functionality to perform averaging have
        a different, larger, minimum integration time for acquisition when averaging is enabled.
        Refer to the documentation for your spectrometer to see if this is the case.
        The minimum integration time when averaging is enabled can be determined
        using odapi_get_minimum_averaging_integration_time_micros.
        @return The minimum averaging integration time.
        """

        err_cp       = (c_long * 1)(0)
        int_time_min = self.oceandirect.odapi_get_minimum_averaging_integration_time_micros(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_minimum_averaging_integration_time")
            raise OceanDirectError(err_cp[0], error_msg)
        return int_time_min

    def set_integration_time(self, int_time: int) -> None:
        """!
        Sets the integration time on the device. This should be verified to be within range prior
        to calling this function.
        @param[in] int_time The new integration time in microseconds. See device manual for supported integration increment.
        """

        self.integration_time = int_time
        err_cp    = (c_long * 1)(0)
        error_msg = self.oceandirect.odapi_set_integration_time_micros(self.device_id, err_cp, c_ulong(int_time))

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"set_integration_time")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_integration_time(self) -> int:
        """!
        Returns the current integration time on the device.
        @return The integration time in microsecond.
        """

        err_cp   = (c_long * 1)(0)
        int_time = self.oceandirect.odapi_get_integration_time_micros(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_integration_time")
            raise OceanDirectError(err_cp[0], error_msg)

        return int_time

    def get_integration_time_increment(self) -> int:
        """!
        Returns the integration time increment on the device.
        @return The integration time increment in microsecond.
        """

        err_cp   = (c_long * 1)(0)
        int_time = self.oceandirect.odapi_get_integration_time_increment_micros(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_integration_time_increment")
            raise OceanDirectError(err_cp[0], error_msg)

        return int_time

    def set_trigger_mode(self, mode: int) -> None:
        """!
        Set the device trigger mode.
        @param[in] mode Trigger mode. See device manual for the supported trigger mode.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_adv_set_trigger_mode(self.device_id, err_cp, mode)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "set_trigger_mode")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_trigger_mode(self) -> None:
        """!
        Returns the current trigger mode from the device. If this function is not
        supported by the device then an exception will be thrown.
        @return The trigger mode.
        """

        err_cp  = (c_long * 1)(0)
        trigger = self.oceandirect.odapi_adv_get_trigger_mode(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_trigger_mode")
            raise OceanDirectError(err_cp[0], error_msg)

        return trigger

    def get_index_at_wavelength(self, wavelength: float) -> tuple[int, float]:
        """!
        Given an approximate wavelength, finds the closest wavelength and returns the index (pixel number) of that
        wavelength, and the exact wavelength as an ordered pair
        @param[in] wavelength A double value containing a best guess or approximate (this should be within bounds
                              of the entire wavelength array or an error is generated).
        @return A pair value (tuple) of index (pixel) and wavelength value.
        """

        new_wl = (c_double * 1)(0)
        err_cp = (c_long * 1)(0)
        index  = self.oceandirect.odapi_get_index_at_wavelength(self.device_id, err_cp, new_wl, c_double(wavelength))

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_index_at_wavelength")
            raise OceanDirectError(err_cp[0], error_msg)
        return index, new_wl[0]

    def get_indices_at_wavelengths(self, wavelengths: list[float]) -> tuple[list[int], list[float]]:
        """!
        Given a list of approximate wavelengths, finds the closest wavelengths and returns the indices (pixel numbers) of those
        wavelengths, and the exact wavelength as an ordered pair of lists
        @param[in] wavelengths  List of approximate wavelengths.
        @return A pair value (tuple) of list(indices) and list(actual_wavelengths).
        """
        wavelengthCount = len(self.get_wavelengths())
        length       = len(wavelengths)
        c_indices    = (c_int * wavelengthCount)()
        c_wavelength = (c_double * wavelengthCount)(*wavelengths)
        
        err_cp       = (c_long * 1)(0)
        indexCount   = self.oceandirect.odapi_get_indices_at_wavelengths(self.device_id, err_cp, c_indices, length, c_wavelength, length)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_indices_at_wavelengths")
            raise OceanDirectError(err_cp[0], error_msg)

        #trim the list
        return list(c_indices[:indexCount]), list(c_wavelength[:indexCount])

    def get_indices_at_wavelength_range(self, lo: float, hi: float, length: int) -> tuple[list[int], list[float]]:
        """!
        Given a list of approximate wavelengths, finds the closest wavelengths and returns the indices
        (pixel numbers) of those wavelengths, and the exact wavelength as an ordered pair of lists.
        @param[in] lo     Wavelength lower limit.
        @param[in] hi     Wavelength upper limit.
        @param[in] length The number of wavelengths to return.
        @return A pair value (tuple) of list(indices) and list(actual_wavelengths)
        """

        wavelengthCount = len(self.get_wavelengths())
        c_indices    = (c_int * wavelengthCount)()
        c_wavelength = (c_double * wavelengthCount)() 
        err_cp       = (c_long * 1)(0)
        wavelengthFoundCount = self.oceandirect.odapi_get_indices_at_wavelength_range(self.device_id, err_cp, c_indices, wavelengthCount,
                                                                                      c_wavelength, wavelengthCount, c_double(lo), c_double(hi))

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_indices_at_wavelength_range")
            raise OceanDirectError(err_cp[0], error_msg)
        
        if wavelengthFoundCount == 0:
            return list(), list()
        elif wavelengthFoundCount < length:
            return list(c_indices[:wavelengthFoundCount]), list(c_wavelength[:wavelengthFoundCount])
        else:
            return list(c_indices[:length]), list(c_wavelength[:length])

    def get_number_electric_dark_pixels(self) -> int:
        """!
        This returns the number of pixels that are electrically active but optically
        masked (a.k.a. electric dark pixels).  Note that not all detectors have optically masked pixels;
        in that case, this function will return zero.
        @return The number of electric dark pixels on the spectrometer.
        """

        err_cp = (c_long * 1)(0)
        self.num_electric_dark_pixels = self.oceandirect.odapi_get_electric_dark_pixel_count(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_number_electric_dark_pixels")
            raise OceanDirectError(err_cp[0], error_msg)

        return self.num_electric_dark_pixels

    def get_electric_dark_pixel_indices(self) -> list[int]:
        """!
        This returns array (up to the given length) with the indices of the pixels that are electrically active
        but optically masked (a.k.a. electric dark pixels).  Note that not all detectors have optically
        masked pixels; in that case, this function will return zero.
        @return A list of pixels that are electric dark on that spectrometer.
        """

        if self.num_electric_dark_pixels is None:
            self.get_number_electric_dark_pixels()
        ed_idx_c = (c_int * self.num_electric_dark_pixels)()
        err_cp   = (c_long * 1)(0)
        self.oceandirect.odapi_get_electric_dark_pixel_indices(self.device_id, err_cp, ed_idx_c, self.num_electric_dark_pixels)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"electric_dark_pixel_count")
            raise OceanDirectError(err_cp[0], error_msg)
        self.electric_dark_pixels = list(ed_idx_c)

        return self.electric_dark_pixels
    
    def details(self) -> None:
        """!
        Prints the defined set of details about the device.
        """

        logger.info("Device ID    : %d    status %s" % (self.device_id, self.status))
        logger.info("Serial Number: %s" % self.get_serial_number())
        logger.info("Model        : %s" % self.get_model())
        logger.info("Number pixels: %d" % self.pixel_count_formatted)

    def is_feature_id_enabled(self, featureID: FeatureID) -> bool:
        """!
        Check if the given feature ID is supported by the device or not.
        @param[in] featureID An id from FeatureID enum.
        @return True if the feature is supported otherwise it's false.
        """
        err_cp = (c_long * 1)(0)
        feature_supported =self.oceandirect.odapi_is_feature_enabled(self.device_id, err_cp, featureID.value)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "is_feature_id_enabled")
            raise OceanDirectError(err_cp[0], error_msg)

        return bool(c_ubyte(feature_supported))

    def set_acquisition_delay(self, delayMicrosecond: int) -> None:
        """!
        Set the acquisition delay in microseconds.  This may also be referred to as the
        trigger delay. In any event, it is the time between some event (such as a request
        for data, or an external trigger pulse) and when data acquisition begins.
        @param[in] delayMicrosecond The new delay to use in microseconds.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_set_acquisition_delay_microseconds(self.device_id, err_cp, c_ulong(delayMicrosecond))

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "set_acquisition_delay_microseconds")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_acquisition_delay(self) -> int:
        """!
        Get the acquisition delay in microseconds.  This may also be referred to as the
        trigger delay.  In any event, it is the time between some event (such as a request
        for data, or an external trigger pulse) and when data acquisition begins.
        Note that not all devices support reading this value back.  In these cases, the
        returned value will be the last value sent to odapi_adv_set_acquisition_delay_microseconds().
        If no value has been set and the value cannot be read back, this function will
        indicate an error.
        @return The acquisition delay in microseconds.
        """

        err_cp = (c_long * 1)(0)
        delay_microsecond = self.oceandirect.odapi_get_acquisition_delay_microseconds(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_acquisition_delay_microseconds")
            raise OceanDirectError(err_cp[0], error_msg)
        return delay_microsecond

    def get_acquisition_delay_increment(self) -> int:
        """!
        Get the allowed step size for the acquisition delay in microseconds.
        @return The acquisition delay step size in microseconds.
        """

        err_cp = (c_long * 1)(0)
        delay_increment_microsecond = self.oceandirect.odapi_get_acquisition_delay_increment_microseconds(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_acquisition_delay_increment_microseconds")
            raise OceanDirectError(err_cp[0], error_msg)
        return delay_increment_microsecond

    def get_acquisition_delay_maximum(self) -> int:
        """!
        Get the maximum allowed acquisition delay in microseconds.
        @return The maximum acquisition delay in microseconds.
        """

        err_cp = (c_long * 1)(0)
        delay_maximum_microsecond = self.oceandirect.odapi_get_acquisition_delay_maximum_microseconds(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_acquisition_delay_maximum_microseconds")
            raise OceanDirectError(err_cp[0], error_msg)
        return delay_maximum_microsecond

    def get_acquisition_delay_minimum(self) -> int:
        """!
        Get the minimum allowed acquisition delay in microseconds.
        @return The minimum acquisition delay in microseconds.
        """

        err_cp = (c_long * 1)(0)
        delay_minimum_microsecond = self.oceandirect.odapi_get_acquisition_delay_minimum_microseconds(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_acquisition_delay_minimum_microseconds")
            raise OceanDirectError(err_cp[0], error_msg)
        return delay_minimum_microsecond

    def set_stored_dark_spectrum(self, darkSpectrum: list[float]) -> None:
        """!
        Store a dark spectrum for use in subsequent corrections i.e. dark correction and nonlinearity correction.
        @see getStoredDarkSpectrum.
        @param darkSpectrum[in] the buffer that contains the dark spectrum to be stored.
        """

        if len(darkSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"set_stored_dark_spectrum")
            raise OceanDirectError(10, error_msg)

        err_cp             = (c_long * 1)(0)
        double_array_count = len(darkSpectrum)
        double_array       = (c_double * double_array_count)(0)
        for x in range(double_array_count):
            double_array[x] = darkSpectrum[x]

        self.oceandirect.odapi_set_stored_dark_spectrum(self.device_id, err_cp, double_array, double_array_count)

        if err_cp[0] != 0:
           error_msg = self.decode_error(err_cp[0],"set_stored_dark_spectrum")
           raise OceanDirectError(err_cp[0], error_msg)

    def get_stored_dark_spectrum(self) -> list[float]:
        """!
        Retrieve a previously stored dark spectrum for use in subsequent corrections i.e. dark correction and nonlinearity correction.
        @see setStoredDarkSpectrum.
        @return The dark spectrum.
        """

        double_array = (c_double * self.pixel_count_formatted)()
        err_cp       = (c_long * 1)(0)
        self.oceandirect.odapi_get_stored_dark_spectrum(self.device_id, err_cp, double_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_stored_dark_spectrum")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(double_array)

    def get_dark_corrected_spectrum1(self, darkSpectrum: list[float]) -> list[float]:
        """!
        Acquire a spectrum and use the supplied dark spectrum to perform a dark correction then return the dark corrected spectrum.
        @param darkSpectrum[in] the buffer that contains the dark spectrum to be used for the dark correction.
        @return The dark corrected spectrum.
        """

        if len(darkSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"get_dark_corrected_spectrum1")
            raise OceanDirectError(10, error_msg)

        corrected_spectrum_array  = (c_double * self.pixel_count_formatted)()
        dark_spectrum_array_count = len(darkSpectrum)
        dark_spectrum_array       = (c_double * dark_spectrum_array_count)()
        err_cp                    = (c_long * 1)(0)
        for x in range(dark_spectrum_array_count):
            dark_spectrum_array[x] = darkSpectrum[x]

        self.oceandirect.odapi_get_dark_corrected_spectrum1(self.device_id, err_cp, dark_spectrum_array, dark_spectrum_array_count,
                                                            corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_dark_corrected_spectrum1")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def dark_correct_spectrum1(self, illuminatedSpectrum: list[float]) -> list[float]:
        """!
        Dark correct a previously acquired illuminated spectrum and using a stored dark spectrum.
        @see setStoredDarkSpectrum
        @param illuminatedSpectrum[in] the buffer that contains the illuminated spectrum to be corrected.
        @return The dark corrected spectrum.
        """

        if len(illuminatedSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"dark_correct_spectrum1")
            raise OceanDirectError(10, error_msg)

        corrected_spectrum_array         = (c_double * self.pixel_count_formatted)()
        illuminated_spectrum_array_count = len(illuminatedSpectrum)
        illuminated_spectrum_array       = (c_double * illuminated_spectrum_array_count)()
        err_cp                           = (c_long * 1)(0)
        for x in range(illuminated_spectrum_array_count):
            illuminated_spectrum_array[x] = illuminatedSpectrum[x]

        self.oceandirect.odapi_dark_correct_spectrum1(self.device_id, err_cp, illuminated_spectrum_array, illuminated_spectrum_array_count,
                                                      corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"dark_correct_spectrum1")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def get_dark_corrected_spectrum2(self) -> list[float]:
        """!
        Acquire a spectrum and use the previously stored dark spectrum to perform a dark correction then return the dark corrected spectrum.
        @see setStoredDarkSpectrum.
        @return The dark corrected spectrum.
        """

        corrected_spectrum_array = (c_double * self.pixel_count_formatted)()
        err_cp                   = (c_long * 1)(0)
        self.oceandirect.odapi_get_dark_corrected_spectrum2(self.device_id, err_cp, corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_dark_corrected_spectrum2")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def dark_correct_spectrum2(self, darkSpectrum: list[float], illuminatedSpectrum: list[float]) -> list[float]:
        """!
        Dark correct a previously acquired illuminated spectrum and using a previously acquired dark spectrum.
        @param darkSpectrum[in] the buffer that contains the dark spectrum to be used for the dark correction.
        @param illuminatedSpectrum[in] the buffer that contains the illuminated spectrum to be corrected.
        @return The dark corrected spectrum.
        """

        if len(darkSpectrum) == 0 or len(illuminatedSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"dark_correct_spectrum2")
            raise OceanDirectError(10, error_msg)

        corrected_spectrum_array         = (c_double * self.pixel_count_formatted)()
        dark_spectrum_array_count        = len(darkSpectrum)
        dark_spectrum_array              = (c_double * dark_spectrum_array_count)()
        illuminated_spectrum_array_count = len(illuminatedSpectrum)
        illuminated_spectrum_array       = (c_double * illuminated_spectrum_array_count)()
        err_cp                           = (c_long * 1)(0)
        for x in range(dark_spectrum_array_count):
            dark_spectrum_array[x] = darkSpectrum[x]

        for x in range(illuminated_spectrum_array_count):
            illuminated_spectrum_array[x] = illuminatedSpectrum[x]

        self.oceandirect.odapi_dark_correct_spectrum2(self.device_id, err_cp, dark_spectrum_array, dark_spectrum_array_count,
                                                      illuminated_spectrum_array, illuminated_spectrum_array_count,
                                                      corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"dark_correct_spectrum2")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array) 

    def get_nonlinearity_corrected_spectrum1(self, darkSpectrum: list[float]) -> list[float]:
        """!
        Acquire a spectrum and use the supplied dark spectrum to perform a dark correction
        followed by the nonlinearity correction then return the nonlinearity corrected spectrum.
        @param darkSpectrum[in] the buffer that contains the dark spectrum to be used for the dark correction.
        @return The nonlinearity corrected spectrum.
        """

        if len(darkSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"get_nonlinearity_corrected_spectrum1")
            raise OceanDirectError(10, error_msg)
    
        corrected_spectrum_array  = (c_double * self.pixel_count_formatted)()
        dark_spectrum_array_count = len(darkSpectrum)
        dark_spectrum_array       = (c_double * dark_spectrum_array_count)()
        err_cp                    = (c_long * 1)(0)
        for x in range(dark_spectrum_array_count):
            dark_spectrum_array[x] = darkSpectrum[x]

        self.oceandirect.odapi_get_nonlinearity_corrected_spectrum1(self.device_id, err_cp, dark_spectrum_array, dark_spectrum_array_count,
                                                                    corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_nonlinearity_corrected_spectrum1")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def nonlinearity_correct_spectrum1(self, illuminatedSpectrum: list[float]) -> list[float]:
        """!
        Nonlinearity correct a previously acquired illuminated spectrum  using a stored dark spectrum.
        This function performs a dark correction using a previously stored dark spectrum prior to performing the nonlinearity correction.
        @see setStoredDarkSpectrum
        @param illuminatedSpectrum[in] the buffer that contains the illuminated spectrum to be corrected.
        @return The nonlinearity corrected spectrum.
        """
        if len(illuminatedSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"nonlinearity_correct_spectrum1")
            raise OceanDirectError(10, error_msg)
    
        corrected_spectrum_array         = (c_double * self.pixel_count_formatted)()
        illuminated_spectrum_array_count = len(illuminatedSpectrum)
        illuminated_spectrum_array       = (c_double * illuminated_spectrum_array_count)()
        err_cp                           = (c_long * 1)(0)
        for x in range(illuminated_spectrum_array_count):
            illuminated_spectrum_array[x] = illuminatedSpectrum[x]

        self.oceandirect.odapi_nonlinearity_correct_spectrum1(self.device_id, err_cp, illuminated_spectrum_array, illuminated_spectrum_array_count,
                                                              corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"nonlinearity_correct_spectrum1")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def get_nonlinearity_corrected_spectrum2(self) -> list[float]:
        """!
        Acquire a spectrum and use the previously stored dark spectrum to perform a dark correction
        followed by a nonlinearity correction then return the nonlinearity corrected spectrum.
        @see setStoredDarkSpectrum.
        @return The nonlinearity corrected spectrum.
        """

        corrected_spectrum_array = (c_double * self.pixel_count_formatted)()
        err_cp                   = (c_long * 1)(0)

        self.oceandirect.odapi_get_nonlinearity_corrected_spectrum2(self.device_id, err_cp, corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"get_nonlinearity_corrected_spectrum2")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def nonlinearity_correct_spectrum2(self, darkSpectrum: list[float], illuminatedSpectrum: list[float]) -> list[float]:
        """!
        Nonlinearity correct a previously acquired illuminated spectrum after dark correction using a previously acquired dark spectrum.
        @param darkSpectrum[in] the buffer that contains the dark spectrum to be used prior to the nonlinearity correction.
        @param illuminatedSpectrum[in] the buffer that contains the illuminated spectrum to be corrected.
        @return The nonlinearity corrected spectrum.
        """
        if len(darkSpectrum) == 0 or len(illuminatedSpectrum) == 0:
            #code 10 means missing value
            error_msg = self.decode_error(10,"nonlinearity_correct_spectrum2")
            raise OceanDirectError(10, error_msg)

        corrected_spectrum_array         = (c_double * self.pixel_count_formatted)()
        dark_spectrum_array_count        = len(darkSpectrum)
        dark_spectrum_array              = (c_double * dark_spectrum_array_count)()
        illuminated_spectrum_array_count = len(illuminatedSpectrum)
        illuminated_spectrum_array       = (c_double * illuminated_spectrum_array_count)()
        err_cp                           = (c_long * 1)(0)

        for x in range(dark_spectrum_array_count):
            dark_spectrum_array[x] = darkSpectrum[x]

        for x in range(illuminated_spectrum_array_count):
            illuminated_spectrum_array[x] = illuminatedSpectrum[x]

        self.oceandirect.odapi_nonlinearity_correct_spectrum2(self.device_id, err_cp, dark_spectrum_array, dark_spectrum_array_count,
                                                              illuminated_spectrum_array, illuminated_spectrum_array_count,
                                                              corrected_spectrum_array, self.pixel_count_formatted)
        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0],"nonlinearity_correct_spectrum2")
            raise OceanDirectError(err_cp[0], error_msg)
        return list(corrected_spectrum_array)

    def set_electric_dark_correction_usage(self, isEnabled: bool) -> None:
        """!
        Enable or disable an electric dark correction.
        @param[in] isEnabled True to enable electric dark correction otherwise it's False.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_apply_electric_dark_correction_usage(self.device_id, err_cp, isEnabled)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "set_electric_dark_correction_usage")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_electric_dark_correction_usage(self) -> bool:
        """!
        Return electric dark correction usage.
        @return True if electric dark connection is applied otherwise it's False.
        """

        err_cp = (c_long * 1)(0)
        correctionState = self.oceandirect.odapi_get_electric_dark_correction_usage(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_electric_dark_correction_usage")
            raise OceanDirectError(err_cp[0], error_msg)

        return bool(c_ubyte(correctionState))

    def set_nonlinearity_correction_usage(self, isEnabled: bool) -> None:
        """!
        Enable or disable nonlinearity correction.
        @param[in] isEnabled True to enable nonlinearity correction otherwise it's False.
        """

        err_cp = (c_long * 1)(0)
        self.oceandirect.odapi_apply_nonlinearity_correct_usage(self.device_id, err_cp, isEnabled)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "set_nonlinearity_correction_usage")
            raise OceanDirectError(err_cp[0], error_msg)

    def get_nonlinearity_correction_usage(self) -> bool:
        """!
        Return nonlinearity correction usage.
        @return True if nonlinearity connection is applied otherwise it's False.
        """

        err_cp = (c_long * 1)(0)
        correctionState = self.oceandirect.odapi_get_nonlinearity_correct_usage(self.device_id, err_cp)

        if err_cp[0] != 0:
            error_msg = self.decode_error(err_cp[0], "get_nonlinearity_correction_usage")
            raise OceanDirectError(err_cp[0], error_msg)

        return bool(c_ubyte(correctionState))


    class Advanced():
        """!
        Subclass containing advanced features that may or may not be in the spectrometer. The spectrometer
        specification guide (manual) should be consulted prior to using any of these features.
        """

        lamp_on = c_ubyte(1)
        lamp_off = c_ubyte(0)
        num_nonlinearity_coeffs = 8

        def __init__(self, device: 'Spectrometer'):
            self.device = device
            self._temperature_count = None

        def set_enable_lamp(self, enable: bool) -> None:
            """!
            Enable or disable the lamp.
            @param[in] enable True to enable lamp, False otherwise.
            """

            err_cp = (c_long * 1)(0)

            if enable :
                self.device.oceandirect.odapi_adv_set_lamp_enable(self.device.device_id, err_cp, self.lamp_on)
            else:
                self.device.oceandirect.odapi_adv_set_lamp_enable(self.device.device_id, err_cp, self.lamp_off)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"enable_lamp")
                raise OceanDirectError(err_cp[0], error_msg)
 
        def get_enable_lamp(self) -> bool:
            """!
            Return the lamp state.
            @return True if lamp is ON otherwise False.
            """

            err_cp = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_get_lamp_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_enable_lamp")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enabled))

        def set_shutter_open(self, shutterState: bool) -> None:
            """!
            This function will open or close the shutter on the spectrometer.
            @param[in[ shutterState  True will open the shutter. False will then close the shutter.
            """
            err_cp = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_set_shutter_open(self.device.device_id, err_cp, c_ubyte(shutterState))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"set_shutter_open")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_shutter_state(self) -> None:
            """!
            This function returns the shutter state of the spectrometer.
            @return True if the shutter is opened otherwise returns False.
            """
            err_cp = (c_long * 1)(0)
            shutterState = self.device.oceandirect.odapi_adv_get_shutter_state(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_shutter_state")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(shutterState))

        def get_wavelength_coeffs(self) -> list[float]:
            """!
            Read the wavelength coefficients from the device. This command is being used in OBP-2.0 enabled devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return List of wavelength coefficient values.
            """

            wl_c = (c_double * 20)()
            err_cp = (c_long * 1)(0)
            buffer_size = self.device.oceandirect.odapi_get_wavelength_coeffs(self.device.device_id, err_cp, wl_c, 20)

            logger.info("Buffer size returned: %d  " % (buffer_size))
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_wavelength_coeffs")
                raise OceanDirectError(err_cp[0], error_msg)

            return list(wl_c)[:buffer_size]

        def get_nonlinearity_coeffs(self) -> list[float]:
            """!
            Read the nonlinearity coefficients stored in the device. This command is being used in OBP-2.0 enabled devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return A list of nonlinearity coefficients.
            """

            num_coeffs = self.num_nonlinearity_coeffs
            nl_coeff   = (c_double * num_coeffs)(0)
            err_cp     = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_get_nonlinearity_coeffs(self.device.device_id, err_cp, nl_coeff, num_coeffs)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_nonlinearity_coeffs")
                raise OceanDirectError(err_cp[0], error_msg)

            return list(nl_coeff)

        def get_nonlinearity_coeffs_count1(self) -> int:
            """!
            Read the nonlinearity coefficients count from the device. This command is being used in legacy devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return The nonlinearity coefficients count.
            """

            err_cp = (c_long * 1)(0)
            nl_count = self.device.oceandirect.odapi_adv_get_nonlinearity_coeffs_count1(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_nonlinearity_coeffs_count1")
                raise OceanDirectError(err_cp[0], error_msg)

            return nl_count

        def get_nonlinearity_coeffs1(self, index: int) -> float:
            """!
            Read the nonlinearity coefficients count of a given position from the device. This command is being used in legacy devices.
            If the device don't support this command then a non-zero error code will be returned. Use the function
            "get_nonlinearity_coeffs_count1()" to get the correct range of the index value.
            @param[in] index A zero based value referring to the coefficient position.
            @return The nonlinearity coefficients.
            """

            self.device.oceandirect.odapi_adv_get_nonlinearity_coeffs1.restype = c_double

            err_cp = (c_long * 1)(0)
            nl_coefficient = self.device.oceandirect.odapi_adv_get_nonlinearity_coeffs1(self.device.device_id, err_cp, c_int(index))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_nonlinearity_coeffs1")
                raise OceanDirectError(err_cp[0], error_msg)

            return nl_coefficient

        def get_tec_temperature_degrees_C(self) -> float:
            """!
            Returns the temperature reading (celsius) of a detector thermistor. This is equivalent to calling
            get_temperature(index) where the "index" is a detector thermistor index. If this function is not
            supported by the device then an exception will be thrown.
            @return The temperature in degrees celsius.
            """

            self.device.oceandirect.odapi_adv_tec_get_temperature_degrees_C.restype = c_double
            err_cp = (c_long * 1)(0)
            temp   = self.device.oceandirect.odapi_adv_tec_get_temperature_degrees_C(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_tec_temperature_degrees_C")
                raise OceanDirectError(err_cp[0], error_msg)
            return temp

        def set_temperature_setpoint_degrees_C(self, temp_C: float) -> None:
            """!
            Apply the setpoint temperature (Celsius) in the thermo-electric cooler. If this function is not
            supported by the device then an exception will be thrown.
            @param[in] temp_C The setpoint temperature in celsius.
            """

            err_cp = (c_long * 1)(0)
            temp   = self.device.oceandirect.odapi_adv_tec_set_temperature_setpoint_degrees_C(self.device.device_id, err_cp, c_double(temp_C))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"set_tec_setpoint")
                raise OceanDirectError(err_cp[0], error_msg)
            #return temp

        def set_tec_enable(self, coolerEnable: bool) -> None:
            """!
            Enable or disable the thermo-electric cooler attached to the detector. If this function is not
            supported by the device then an exception will be thrown.
            @param[in] coolerEnable True to enable the cooler, False otherwise.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_tec_set_enable(self.device.device_id, err_cp, c_ubyte(coolerEnable))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_tec_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_tec_enable(self) -> bool:
            """!
            Read the state of the thermo-electric cooler whether it's enable or disable. If this function
            is not supported by the device then an exception will be thrown.
            @return True if the thermo-electric cooler is enabled, False otherwise.
            """

            err_cp  = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_tec_get_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_tec_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enabled))

        def get_temperature_setpoint_degrees_C(self) -> float:
            """!
            Read the set point temperature of the thermo-electric cooler. If this function is not supported
            by the device then an exception will be thrown.
            @return The temperature value in celsius.
            """

            self.device.oceandirect.odapi_adv_tec_get_temperature_setpoint_degrees_C.restype = c_float
            err_cp = (c_long * 1)(0)
            temp   = self.device.oceandirect.odapi_adv_tec_get_temperature_setpoint_degrees_C(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_tec_setpoint")
                raise OceanDirectError(err_cp[0], error_msg)
            return temp

        def get_tec_stable(self) -> bool:
            """!
            Returns the state of thermo-electric cooler temperature on whether it reached the stable
            temperature or not. If this function is not supported by the device then an exception will be thrown.
            @return True if it's stable, False otherwise.
            """

            err_cp  = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_tec_get_stable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_tec_stable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enabled))

        def get_tec_fan_enable(self) -> bool:
            """!
            Returns the thermo-electric cooler fan state whether it's enabled or not. Few devices have cooler fan.
            If this function is not supported by the device then an exception will be thrown.
            @return True if the fan is enabled, False otherwise.
            """

            err_cp  = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_tec_get_fan_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_tec_fan_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enabled))

        def get_light_source_count(self) -> int:
            """!
            Gets the number of light sources that are represented by the given featureID. Such
            light sources could be individual LEDs, light bulbs, lasers, etc.  Each of these light
            sources may have different capabilities, such as programmable intensities and enables,
            which should be queried before they are used.
            @return The number of light sources (e.g. bulbs) in the indicated feature
            """

            err_cp = (c_long * 1)(0)
            light_source_count = self.device.oceandirect.odapi_adv_get_light_source_count(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_light_source_count")
                raise OceanDirectError(err_cp[0], error_msg)

        def has_light_source_enable(self, light_source_index: int) -> bool:
            """!
            Queries whether the indicated light source within the given feature instance has a usable
            enable/disable control. If this returns False (meaning no enable available) then calling enable_light_source()
	        or is_light_source_enabled() is likely to result in an error.
            @param[in] light_source_index Which of potentially many light sources (LEDs, lasers, light bulbs)
                                       within the indicated feature instance to query
            @return False to indicate specified light source cannot be enabled/disabled. True to indicate specified
                     light source can be enabled/disabled with enable_light_source()
            """

            err_cp = (c_long * 1)(0)
            status = self.device.oceandirect.odapi_adv_light_source_has_enable(self.device.device_id, err_cp, light_source_index)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "has_light_source_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(status)

        def is_light_source_enabled(self, light_source_index: int) -> bool:
            """!
            Queries whether the indicated light source within the given feature instance is enabled (energized).
            @param[in] light_source_index Which of potentially many light sources (LEDs, lasers, light bulbs)
                                          within the indicated feature instance to query.
            @return False to indicate specified light source is disabled (should emit no light). True to indicate
                     specified light source is enabled (should emit light depending on configured intensity setting).
            """

            err_cp = (c_long * 1)(0)
            status = self.device.oceandirect.odapi_adv_light_source_is_enabled(self.device.device_id, err_cp, light_source_index)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "is_light_source_enabled")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(status)

        def enable_light_source(self, light_source_index: int, enable: bool) -> None:
            """!
            Attempts to enable or disable the indicated light source within the given feature instance.  Not
            all light sources have an enable/disable control, and this capability can be queried with has_light_source_enable().
	        Note that an enabled light source should emit light according to its last (or default) intensity
	        setting which might be the minimum; in this case, the light source might appear to remain off.
            @param[in] light_source_index  Which of potentially many light sources (LEDs, lasers, light bulbs) within
                                    the indicated feature instance to query.
            @param[in] enable  Whether to enable the light source.  A value of False will attempt to disable the
                           light source, and any other value will enable it.
            """

            err_cp = (c_long * 1)(0)

            if enable :
                self.device.oceandirect.odapi_adv_light_source_set_enable(self.device.device_id,  err_cp, light_source_index, self.lamp_on)
            else:
                self.device.oceandirect.odapi_adv_light_source_set_enable(self.device.device_id, err_cp, light_source_index, self.lamp_off)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "enable_light_source")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_single_strobe_enable(self, enable: bool) -> None:
            """!
            Set the enable status of the single strobe signal.  Note that on some
            devices the enable control is shared with other signals (e.g. lamp
            enable and continuous strobe) so this may have some side-effects and
            changing those features may affect the single strobe as well.
            @param[in] enable  True to enable single strobe otherwise use False.
            """

            err_cp = (c_long * 1)(0)

            if enable :
                self.device.oceandirect.odapi_adv_set_single_strobe_enable(self.device.device_id, err_cp, self.lamp_on)
            else:
                self.device.oceandirect.odapi_adv_set_single_strobe_enable(self.device.device_id, err_cp, self.lamp_off)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_single_strobe_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_single_strobe_delay(self, delayMicrosecond: int) -> None:
            """!
            Set the amount of time, in microseconds, that should elapse after a starting event before
            the single strobe should have a rising edge.
            @param[in] delayMicrosecond The delay, in microseconds, that the single strobe should wait before
                                      the pulse begins.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_single_strobe_delay(self.device.device_id, err_cp, c_ulong(delayMicrosecond))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_single_strobe_delay")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_single_strobe_width(self, widthMicrosecond: int) -> None:
            """!
            Set the amount of time, in microseconds, that the single strobe pulse should remain high after it begins.
            @param[in] widthMicrosecond  The duration, in microseconds, of the single strobe pulse after
                                      the rising edge occurs. Once this duration elapses, a falling edge
                                      will be generated.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_single_strobe_width(self.device.device_id, err_cp, c_ulong(widthMicrosecond))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_single_strobe_width")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_single_strobe_enable(self) -> bool:
            """!
            Get the enable status of the single strobe signal.  Note that on some
            devices the enable control is shared with other signals (e.g. lamp
            enable and continuous strobe) so this may have some side-effects and
            changing those features may affect the single strobe as well.
            @return True if single strobe is enabled otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            enable = self.device.oceandirect.odapi_adv_get_single_strobe_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "is_single_strobe_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enable))

        def get_single_strobe_delay(self) -> int:
            """!
            Get the amount of time, in microseconds, that should elapse after
            a starting event before the single strobe should have a rising edge
            @return The delay in microseconds.
            """

            err_cp = (c_long * 1)(0)
            delay_microsecond = self.device.oceandirect.odapi_adv_get_single_strobe_delay(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_delay")
                raise OceanDirectError(err_cp[0], error_msg)
            return delay_microsecond

        def get_single_strobe_width(self) -> int:
            """!
            Get the amount of time, in microseconds, that the single strobe pulse
	        should remain high after it begins.
            @return The pulse width in microseconds.
            """

            err_cp = (c_long * 1)(0)
            width_microsecond = self.device.oceandirect.odapi_adv_get_single_strobe_width(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_width")
                raise OceanDirectError(err_cp[0], error_msg)
            return width_microsecond

        def get_light_source_count(self) -> int:
            """!
            Gets the number of light sources that are represented by the given featureID. Such
            light sources could be individual LEDs, light bulbs, lasers, etc.  Each of these light
            sources may have different capabilities, such as programmable intensities and enables,
            which should be queried before they are used.

            @return The number of light sources (e.g. bulbs) in the indicated feature
            """

            err_cp = (c_long * 1)(0)
            light_source_count = self.device.oceandirect.odapi_adv_get_light_source_count(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_light_source_count")
                raise OceanDirectError(err_cp[0], error_msg)
            return light_source_count

        def has_light_source_enable(self, light_source_index: int) -> bool:
            """!
            Queries whether the indicated light source within the given feature instance has a usable
            enable/disable control. If this returns False (meaning no enable available) then calling enable_light_source()
	        or is_light_source_enabled() is likely to result in an error.

            @param[in] light_source_index Which of potentially many light sources (LEDs, lasers, light bulbs)
                                       within the indicated feature instance to query
            @return False to indicate specified light source cannot be enabled/disabled. True to indicate specified
                     light source can be enabled/disabled with enable_light_source()
            """

            err_cp = (c_long * 1)(0)
            status = self.device.oceandirect.odapi_adv_light_source_has_enable(self.device.device_id, err_cp, light_source_index)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "has_light_source_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(status)

        def is_light_source_enabled(self, light_source_index: int) -> bool:
            """!
            Queries whether the indicated light source within the given feature instance is enabled (energized).

            @param[in] light_source_index Which of potentially many light sources (LEDs, lasers, light bulbs)
                                          within the indicated feature instance to query.
            @return False to indicate specified light source is disabled (should emit no light). True to indicate
                     specified light source is enabled (should emit light depending on configured intensity setting).
            """

            err_cp = (c_long * 1)(0)
            status = self.device.oceandirect.odapi_adv_light_source_is_enabled(self.device.device_id, err_cp, light_source_index)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "is_light_source_enabled")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(status)

        def enable_light_source(self, light_source_index: int, enable: bool) -> None:
            """!
            Attempts to enable or disable the indicated light source within the given feature instance.  Not
            all light sources have an enable/disable control, and this capability can be queried with has_light_source_enable().
	        Note that an enabled light source should emit light according to its last (or default) intensity
	        setting which might be the minimum; in this case, the light source might appear to remain off.

            @param[in] light_source_index  Which of potentially many light sources (LEDs, lasers, light bulbs) within
                                    the indicated feature instance to query.
            @param[in] enable  Whether to enable the light source.  A value of False will attempt to disable the
                           light source, and any other value will enable it.
            """

            err_cp = (c_long * 1)(0)

            if enable :
                self.device.oceandirect.odapi_adv_light_source_set_enable(self.device.device_id,  err_cp, light_source_index, self.lamp_on)
            else:
                self.device.oceandirect.odapi_adv_light_source_set_enable(self.device.device_id, err_cp, light_source_index, self.lamp_off)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "enable_light_source")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_single_strobe_enable(self, enable: bool) -> None:
            """!
            Set the enable status of the single strobe signal.  Note that on some
            devices the enable control is shared with other signals (e.g. lamp
            enable and continuous strobe) so this may have some side-effects and
            changing those features may affect the single strobe as well.

            @param[in] enable  True to enable single strobe otherwise use False.
            """

            err_cp = (c_long * 1)(0)

            if enable :
                self.device.oceandirect.odapi_adv_set_single_strobe_enable(self.device.device_id, err_cp, self.lamp_on)
            else:
                self.device.oceandirect.odapi_adv_set_single_strobe_enable(self.device.device_id, err_cp, self.lamp_off)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_single_strobe_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_single_strobe_delay(self, delayMicrosecond: int) -> None:
            """!
            Set the amount of time, in microseconds, that should elapse after a starting event before
            the single strobe should have a rising edge.

            @param[in] delayMicrosecond The delay, in microseconds, that the single strobe should wait before
                                      the pulse begins.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_single_strobe_delay(self.device.device_id, err_cp, c_ulong(delayMicrosecond))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_single_strobe_delay")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_single_strobe_width(self, widthMicrosecond: int) -> None:
            """!
            Set the amount of time, in microseconds, that the single strobe pulse should remain high after it begins.

            @param[in] widthMicrosecond  The duration, in microseconds, of the single strobe pulse after
                                      the rising edge occurs. Once this duration elapses, a falling edge
                                      will be generated.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_single_strobe_width(self.device.device_id, err_cp, c_ulong(widthMicrosecond))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_single_strobe_width")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_single_strobe_enable(self) -> bool:
            """!
            Get the enable status of the single strobe signal.  Note that on some
            devices the enable control is shared with other signals (e.g. lamp
            enable and continuous strobe) so this may have some side-effects and
            changing those features may affect the single strobe as well.

            @return True if single strobe is enabled otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            enable = self.device.oceandirect.odapi_adv_get_single_strobe_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "is_single_strobe_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enable))

        def get_single_strobe_delay(self) -> int:
            """!
            Get the amount of time, in microseconds, that should elapse after
            a starting event before the single strobe should have a rising edge

            @return The delay in microseconds.
            """

            err_cp = (c_long * 1)(0)
            delay_microsecond = self.device.oceandirect.odapi_adv_get_single_strobe_delay(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_delay")
                raise OceanDirectError(err_cp[0], error_msg)
            return delay_microsecond

        def get_single_strobe_width(self) -> int:
            """!
            Get the amount of time, in microseconds, that the single strobe pulse
	        should remain high after it begins.

            @return The pulse width in microseconds.
            """

            err_cp = (c_long * 1)(0)
            width_microsecond = self.device.oceandirect.odapi_adv_get_single_strobe_width(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_width")
                raise OceanDirectError(err_cp[0], error_msg)
            return width_microsecond

        def get_single_strobe_delay_minimum(self) -> int:
            """!
            Get the minimum amount of time, in microseconds, that should elapse after
            a starting event before the single strobe should have a rising edge.

            @return The minimum delay in microseconds.
            """

            err_cp = (c_long * 1)(0)
            minimum_microseconds = self.device.oceandirect.odapi_adv_get_single_strobe_delay_minimum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_delay_minimum")
                raise OceanDirectError(err_cp[0], error_msg)
            return minimum_microseconds

        def get_single_strobe_delay_maximum(self) -> int:
            """!
            Get the maximum amount of time, in microseconds, that should elapse after
            a starting event before the single strobe should have a rising edge.

            @return The maximum delay in microseconds.
            """

            err_cp = (c_long * 1)(0)
            maximum_microseconds = self.device.oceandirect.odapi_adv_get_single_strobe_delay_maximum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_delay_maximum")
                raise OceanDirectError(err_cp[0], error_msg)
            return maximum_microseconds

        def get_single_strobe_delay_increment(self) -> int:
            """!
            Gets the single strobe delay increment in microseconds.
            @return The delay increment.
            """
            err_cp = (c_long * 1)(0)
            delay_increment = self.device.oceandirect.odapi_adv_get_single_strobe_delay_increment(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_delay_increment")
                raise OceanDirectError(err_cp[0], error_msg)
            return delay_increment

        def get_single_strobe_width_minimum(self) -> int:
            """!
            Get the minimum amount of time, in microseconds, that the single strobe pulse
	        should remain high after it begins.
            @return The minimum width in microseconds.
            """

            err_cp = (c_long * 1)(0)
            width_minimum = self.device.oceandirect.odapi_adv_get_single_strobe_width_minimum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_width_minimum")
                raise OceanDirectError(err_cp[0], error_msg)
            return width_minimum

        def get_single_strobe_width_maximum(self) -> int:
            """!
            Get the maximum amount of time, in microseconds, that the single strobe pulse
	        should remain high after it begins.
            @return The maximum width in microseconds.
            """
            err_cp = (c_long * 1)(0)
            width_maximum = self.device.oceandirect.odapi_adv_get_single_strobe_width_maximum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_width_maximum")
                raise OceanDirectError(err_cp[0], error_msg)
            return width_maximum

        def get_single_strobe_width_increment(self) -> int:
            """!
            Get the single strobe width increment.
            @return The width increment.
            """
            err_cp = (c_long * 1)(0)
            width_increment = self.device.oceandirect.odapi_adv_get_single_strobe_width_increment(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_width_increment")
                raise OceanDirectError(err_cp[0], error_msg)
            return width_increment

        def get_single_strobe_cycle_maximum(self) -> int:
            """!
            Gets the single strobe cycle maximum in microseconds.
            @return The maximum cycle value.
            """

            err_cp = (c_long * 1)(0)
            cyle_maximum = self.device.oceandirect.odapi_adv_get_single_strobe_cycle_maximum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_single_strobe_cycle_maximum")
                raise OceanDirectError(err_cp[0], error_msg)
            return cyle_maximum

        def set_continuous_strobe_period(self, period: int) -> None:
            """!
            Sets the continuous strobe period in microseconds.
            @param[in] period The new period of the continuous strobe measured in microseconds
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_continuous_strobe_period_micros(self.device.device_id, err_cp, period)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_continuous_strobe_period_micros")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_continuous_strobe_enable(self, enable: bool) -> None:
            """!
            Sets the continuous strobe enable state on the device.
            @param[in] enable A boolean used for denoting the desired state (on/off) of the continuous
                           strobe generator. If the value of enable is nonzero, then the continuous
                           strobe will operate. If the value of enable is zero, then the continuous
                           strobe will stop. Note that on some devices the continuous strobe enable
                           is tied to other enables (such as lamp enable or single strobe enable)
                           which may cause side effects.
            """

            err_cp = (c_long * 1)(0)

            if enable :
                self.device.oceandirect.odapi_adv_set_continuous_strobe_enable(self.device.device_id, err_cp, self.lamp_on)
            else:
                self.device.oceandirect.odapi_adv_set_continuous_strobe_enable(self.device.device_id, err_cp, self.lamp_off)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_continuous_strobe_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_continuous_strobe_period(self) -> int:
            """!
            Get the continuous strobe period in microseconds.
            @return the period in microseconds.
            """

            err_cp = (c_long * 1)(0)
            period_microsecond = self.device.oceandirect.odapi_adv_get_continuous_strobe_period_micros(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_continuous_strobe_period")
                raise OceanDirectError(err_cp[0], error_msg)
            return period_microsecond

        def get_continuous_strobe_enable(self) -> bool:
            """!
            Gets the continuous strobe state (enabled or disabled) of the device.
            @return True if continuous strobe is enabled otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            enable = self.device.oceandirect.odapi_adv_get_continuous_strobe_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "is_continuous_strobe_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enable))

        def get_continuous_strobe_period_minimum(self) -> int:
            """!
            Gets the minimum continuous strobe period of the device in microseconds.
            @return The minimum strobe period in microseconds.
            """

            err_cp = (c_long * 1)(0)
            minimum_microsecond = self.device.oceandirect.odapi_adv_get_continuous_strobe_period_minimum_micros(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_continuous_strobe_period_minimum")
                raise OceanDirectError(err_cp[0], error_msg)
            return minimum_microsecond

        def get_continuous_strobe_period_maximum(self) -> int:
            """!
            Gets the maximum continuous strobe period of the device in microseconds.
            @return The maximum strobe period in microseconds.
            """

            err_cp = (c_long * 1)(0)
            maximum_microsecond = self.device.oceandirect.odapi_adv_get_continuous_strobe_period_maximum_micros(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_continuous_strobe_period_maximum")
                raise OceanDirectError(err_cp[0], error_msg)
            return maximum_microsecond

        def get_continuous_strobe_period_increment(self) -> int:
            """!
            This function gets the current size of the strobe period increment of the device in microseconds.
            The increment is dependent on the strobe period. Small strobe periods i.e. less than about 1ms
            will have a small increment, typically 1 microsecond. Larger strobe periods will have larger
            increments, typically 1ms.
            @return The current strobe period increment in microseconds.
            """

            err_cp = (c_long * 1)(0)
            increment_microsecond = self.device.oceandirect.odapi_adv_get_continuous_strobe_period_increment_micros(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_continuous_strobe_period_increment")
                raise OceanDirectError(err_cp[0], error_msg)
            return increment_microsecond

        def get_continuous_strobe_width(self) -> int:
            """!
            Gets the strobe width of the device in microseconds.
            @return The current strobe width in microseconds.
            """
            err_cp = (c_long * 1)(0)
            width_microsecond = self.device.oceandirect.odapi_adv_get_continuous_strobe_width_micros(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_continuous_strobe_width")
                raise OceanDirectError(err_cp[0], error_msg)
            return width_microsecond

        def set_continuous_strobe_width(self, widthMicrosecond: int) -> None:
            """!
            Sets the continuous strobe width on the device.
            @param[in] widthMicrosecond The new width of the continuous strobe measured in microseconds.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_continuous_strobe_width_micros(self.device.device_id, err_cp, c_ulong(widthMicrosecond))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_continuous_strobe_width")
                raise OceanDirectError(err_cp[0], error_msg)

        def clear_data_buffer(self) -> None:
            """!
            Clear the data buffer. An exception will be thrown if the command is not supported by the device.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_clear_data_buffer(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "clear_data_buffer")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_data_buffer_number_of_elements(self) -> int:
            """!
            Get the number of data elements currently in the buffer. An exception will be thrown if
            the command is not supported by the device.
            @return A count of how many items are available for retrieval from the buffer.
            """

            err_cp = (c_long * 1)(0)
            number_of_elements = self.device.oceandirect.odapi_adv_get_data_buffer_number_of_elements(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_data_buffer_number_of_elements")
                raise OceanDirectError(err_cp[0], error_msg)
            return number_of_elements

        def get_data_buffer_capacity(self) -> int:
            """!
            Get the present limit of how many data elements will be retained by the buffer. This value can be
            changed with set_data_buffer_capacity(). An exception will be thrown if the command is
            not supported by the device.
            @return A count of how many items the buffer will store before data may be lost.
            """

            err_cp = (c_long * 1)(0)
            maximum_buffer = self.device.oceandirect.odapi_adv_get_data_buffer_capacity(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_data_buffer_capacity")
                raise OceanDirectError(err_cp[0], error_msg)
            return maximum_buffer

        def get_data_buffer_capacity_maximum(self) -> int:
            """!
            Get the maximum possible configurable size for the data buffer. An exception will be thrown if
            the command is not supported by the device.
            @return The largest value that may be set with set_data_buffer_capacity().
            """

            err_cp = (c_long * 1)(0)
            maximum_buffer_capacity = self.device.oceandirect.odapi_adv_get_data_buffer_capacity_maximum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_data_buffer_capacity_maximum")
                raise OceanDirectError(err_cp[0], error_msg)
            return maximum_buffer_capacity

        def get_data_buffer_capacity_minimum(self) -> int:
            """!
            Get the minimum possible configurable size for the data buffer. An exception will be thrown if
            the command is not supported by the device.
            @return The smallest value that may be set with set_data_buffer_capacity().
            """

            err_cp = (c_long * 1)(0)
            minimum_buffer_capacity = self.device.oceandirect.odapi_adv_get_data_buffer_capacity_minimum(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_data_buffer_capacity_minimum")
                raise OceanDirectError(err_cp[0], error_msg)
            return minimum_buffer_capacity

        def set_data_buffer_capacity(self, capacity: int) -> None:
            """!
            Set the number of data elements that the buffer should retain. This function must be used
            with "set_number_of_backtoback_scans()". An exception will be thrown if the command is
            not supported by the device.
            @param[in] capacity Limit on the number of data elements to store. This is bounded by what is returned
                             by get_data_buffer_capacity_minimum() and get_data_buffer_capacity_maximum().
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_data_buffer_capacity(self.device.device_id, err_cp, capacity)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_data_buffer_capacity")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_data_buffer_enable(self, enable: bool) -> None:
            """!
            Enable or disable data buffering. An exception will be thrown if the command is
            not supported by the device.
            @param[in] enable True enable the buffer. False disable the buffer.
            """

            flag = c_ubyte(0)
            if enable == True or enable == 1:
                flag = c_ubyte(1)

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_data_buffer_enable(self.device.device_id, err_cp, flag)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_data_buffer_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_data_buffer_enable(self) -> bool:
            """!
            Reads the device data buffering enable state. An exception will be thrown if the command
            is not supported by the device.
            @return True if data buffering is enabled otherwise it's False.
            """

            err_cp          = (c_long * 1)(0)
            dataBufferState = self.device.oceandirect.odapi_adv_get_data_buffer_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_data_buffer_enable")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(dataBufferState))

        def abort_acquisition(self) -> None:
            """!
            Abort spectra acquisition and put the device into an idle state. To resume spectra acquisition,
            you have to call acquire_spectra_to_buffer() first before calling the get spectra command. Very
            few devices supported this command.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_abort_acquisition(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "abort_acquisition")
                raise OceanDirectError(err_cp[0], error_msg)

        def acquire_spectra_to_buffer(self) -> None:
            """!
            Start spectra acquisition. This would transition the device into a non-idle state. Very
            few devices supported this command. An exception will be thrown if the command is
            not supported by the device.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_acquire_spectra_to_buffer(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "acquire_spectra_to_buffer")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_device_idle_state(self) -> bool:
            """!
            Return device idle state. Very few devices supported this command. An exception will be thrown if
            the command is not supported by the device.
            @return True if the device is idle otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            retval = self.device.oceandirect.odapi_adv_get_device_idle_state(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_idle_state")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(retval))

        def get_number_of_backtoback_scans(self) -> int:
            """!
            Get the number of back-to-back scans. See device manual if data buffering is supported.
            @return The back-to-back scan value.
            """

            err_cp = (c_long * 1)(0)
            retval = self.device.oceandirect.odapi_adv_get_number_of_backtoback_scans(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_number_of_backtoback_scans")
                raise OceanDirectError(err_cp[0], error_msg)

            return retval

        def set_number_of_backtoback_scans(self, numScans: int) -> None:
            """!
            Set the number of spectra that the device will capture per trigger event. This function requires
            data buffer to be enabled. See "set_data_buffer_enable()". See device manual if data buffering is supported.
            @param[in] numScans The back-to-back scan value.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_number_of_backtoback_scans(self.device.device_id, err_cp, numScans)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_number_of_backtoback_scans")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_raw_spectrum_with_metadata(self, list_raw_spectra: list[list[float]], list_timestamp: list[int], buffer_size: int) -> int:
            """!
            Returns spectra with metadata information. For older devices such as FX/HDX, read a maximum of 15
            spectra from the data buffer. This function requires that both back to back scans and data buffer
            be enabled. See "set_data_buffer_enable()" and "set_number_of_backtoback_scans()". For newer devices
            such as Ocean SR2, you can call this function right away. See device manual if this command is supported.
            @param[in] list_raw_spectra The spectra output buffer.
            @param[in] list_timestamp   The timestamp output buffer of each spectra.
            @param[in] buffer_size      The buffer array size (maximum is 15).
            @return The number of spectra read. It can be zero.
            """

            buffer = (POINTER(c_double) * buffer_size)()
            for x in range(buffer_size):
                buffer[x] = (c_double * self.device.pixel_count_formatted)()

            timestamp    = (c_longlong * buffer_size)(0)
            err_cp       = (c_long * 1)(0)
            spectraCount = self.device.oceandirect.odapi_get_raw_spectrum_with_metadata(self.device.device_id, err_cp, buffer, buffer_size,
                                                                                        self.device.pixel_count_formatted, timestamp, buffer_size)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_raw_spectrum_with_metadata")
                raise OceanDirectError(err_cp[0], error_msg)

            for x in range(spectraCount):
                spectra = [None] * self.device.pixel_count_formatted

                #Convert c-types into python. There might be a better way to do this.
                for y in range(self.device.pixel_count_formatted):
                    spectra[y] = buffer[x][y]
                
                list_raw_spectra.append(spectra)
                #list_raw_spectra.append(buffer[x])
                list_timestamp.append(timestamp[x])

            return spectraCount

        def get_usb_endpoint_primary_out(self) -> int:
            """!
            This function returns the usb primary OUT endpoint for the type specified. If the type is not
            supported by the device, a zero is returned. 0 is normally the control endpoint. That
            value is not valid in this context.
            @return The usb endpoint address.
            """

            err_cp = (c_long * 1)(0)
            usb_primary_endpoint_out = self.device.oceandirect.odapi_get_device_usb_endpoint_primary_out(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_usb_endpoint_primary_out")
                raise OceanDirectError(err_cp[0], error_msg)
            return int(usb_primary_endpoint_out)

        def get_usb_endpoint_primary_in(self) -> int:
            """!
            This function returns the usb primary IN endpoint for the type specified. If the type is not
            supported by the device, a zero is returned. 0 is normally the control endpoint. That
            value is not valid in this context.
            @return The usb endpoint address.
            """

            err_cp = (c_long * 1)(0)
            usb_primary_endpoint_in = self.device.oceandirect.odapi_get_device_usb_endpoint_primary_in(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_usb_endpoint_primary_in")
                raise OceanDirectError(err_cp[0], error_msg)
            return int(usb_primary_endpoint_in)

        def get_usb_endpoint_secondary_out(self) -> int:
            """!
            This function returns the usb secondary OUT endpoint for the type specified. If the type is
            not supported by the device, a zero is returned. 0 is normally the control endpoint. That
            value is not valid in this context.
            @return The usb endpoint address.
            """

            err_cp = (c_long * 1)(0)
            usb_secondary_endpoint_out = self.device.oceandirect.odapi_get_device_usb_endpoint_secondary_out(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_usb_endpoint_secondary_out")
                raise OceanDirectError(err_cp[0], error_msg)
            return int(usb_secondary_endpoint_out)

        def get_usb_endpoint_secondary_in(self) -> int:
            """!
            This function returns the usb secondary IN endpoint for the type specified. If the type is
            not supported by the device, a zero is returned. 0 is normally the control endpoint. That
            value is not valid in this context.
            @return The usb endpoint address.
            """

            err_cp = (c_long * 1)(0)

            usb_secondary_endpoint_in = self.device.oceandirect.odapi_get_device_usb_endpoint_secondary_in(self.device.device_id, err_cp)
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_usb_endpoint_secondary_in")
                raise OceanDirectError(err_cp[0], error_msg)
            return int(usb_secondary_endpoint_in)

        def get_revision_firmware(self) -> str:
            """!
            Reads out the firmware revision from the device's internal memory if that feature is supported.
            @return The firmware revision.
            """

            err_cp         = (c_long * 1)(0)
            fw_revision_cp = create_string_buffer(b'\000' * 100)
            bytesRead      = self.device.oceandirect.odapi_adv_get_revision_firmware(self.device.device_id, err_cp, fw_revision_cp, 100)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_revision_firmware")
                raise OceanDirectError(err_cp[0], error_msg)
            return fw_revision_cp.value.decode()

        def get_revision_fpga(self) -> str:
            """!
            Reads out the FPGA revision from the device's internal memory if that feature is supported.
            @return The fpga revision.
            """

            err_cp         = (c_long * 1)(0)
            fpga_revision_cp = create_string_buffer(b'\000' * 100)
            bytesRead      = self.device.oceandirect.odapi_adv_get_revision_fpga(self.device.device_id, err_cp, fpga_revision_cp, 100)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_revision_fpga")
                raise OceanDirectError(err_cp[0], error_msg)
            return fpga_revision_cp.value.decode()

        def ipv4_is_dhcp_enabled(self, ifNum: int) -> bool:
            """!
            Check to see if DHCP (client) is enabled on the specified interface. If DHCP is enabled then the
            device will be able to receive an IP address from a DHCP server in the network it is connected to. See
            device manual if TCP/IP connection is supported.
            @param[in] ifNum The interface number: 0 for Ethernet, 1 for wi-fi.
            @return True if DHCP is enabled on the specified interface otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            enable = self.device.oceandirect.odapi_adv_ipv4_is_dhcp_enabled(self.device.device_id, err_cp, c_ubyte(ifNum))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_is_dhcp_enabled")
                raise OceanDirectError(err_cp[0], error_msg)
            return bool(c_ubyte(enable))

        def ipv4_set_dhcp_enable(self, ifNum: int, enabled: bool) -> None:
            """!
            Turn the DHCP client on or off for the device on the specified interface. See device manual if TCP/IP
            connection is supported.
            @param[in] ifNum   The interface number: 0 for Ethernet, 1 for wi-fi.
            @param[in] enabled False turns the DHCP client off. True turns the DHCP client on.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_ipv4_set_dhcp_enable(self.device.device_id, err_cp, ifNum, enabled)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_set_dhcp_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def ipv4_get_number_of_ip_addresses(self, ifNum: int) -> int:
            """!
            Get the number of IP addresses available on the specified interface. If DHCP is enabled on the
            specified interface then index 0 represents the DHCP address and the following addresses
            will be any static IP addresses. See device manual if TCP/IP connection is supported.
            @param[in] ifNum The interface number: 0 for Ethernet, 1 for wi-fi.
            @return The number of IP addresses on the specified interface.
            """

            err_cp       = (c_long * 1)(0)
            numIpAddress = self.device.oceandirect.odapi_adv_ipv4_get_number_of_ip_addresses(self.device.device_id, err_cp, ifNum)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_get_number_of_ip_addresses")
                raise OceanDirectError(err_cp[0], error_msg)
            return numIpAddress;

        def ipv4_read_ip_address(self, ifNum: int, addressIndex: int) -> tuple[list[int], int]:
            """!
            Get the assigned ip address provided by the index of a particular interface. See device manual if
            TCP/IP connection is supported.
            @param[in]  ifNum        The network interface. 0 for ethernet, 1 for wifi.
            @param[in]  addressIndex The location of the ip address. Starts with 0.
            @return A tuple of ip address (4-byte) and network mask (int).
            """
            err_cp        = (c_long * 1)(0)
            netmask_cp    = (c_uint * 1)(0)
            ip_address_cp = (c_ubyte * 4)(0)
            self.device.oceandirect.odapi_adv_ipv4_read_ip_address(self.device.device_id, err_cp, c_ubyte(ifNum), c_ubyte(addressIndex),
                                                                   ip_address_cp, 4, netmask_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_get_number_of_ip_addresses")
                raise OceanDirectError(err_cp[0], error_msg)

            outIpAddress = []
            outNetmask = int(netmask_cp[0])
            for i in range(len(ip_address_cp)):
                outIpAddress.append(int(ip_address_cp[i]))
            return (outIpAddress, outNetmask)

        def ipv4_add_static_ip_address(self, ifNum: int, ipAddress: list[int], netmask: int) -> None:
            """!
            Add a static IP address to the specified interface. The IP address is specified as 4 bytes in an
            array. The leading part of the IP address must contain the first element of the array, followed by the
            remaining parts in order to the last part of the IP address in the fourth element of the array. See
            device manual if TCP/IP connection is supported.
            @param[in] ifNum     The interface number: 0 for Ethernet, 1 for wi-fi.
            @param[in] ipAddress The static IP address to be added. This is 4-byte array data.
            @param[in] netmask   An 8-bit network mask specifying the subnet of the network the device is on.
            """

            err_cp = (c_long * 1)(0)

            if len(ipAddress) != 4:
                error_msg = "ipv4_add_static_ip_address() error:  ipAddress must be an array of 4 bytes long."
                raise OceanDirectError(err_cp[0], error_msg)

            ip_address_cp = (c_ubyte * 4)(0)
            for i in range(4):
                ip_address_cp[i] = ipAddress[i]


            self.device.oceandirect.odapi_adv_ipv4_add_static_ip_address(self.device.device_id, err_cp, c_ubyte(ifNum), ip_address_cp, 4, c_uint(netmask))
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_add_static_ip_address")
                raise OceanDirectError(err_cp[0], error_msg)

        def ipv4_delete_static_ip_address(self, ifNum: int, addressIndex: int) -> None:
            """!
            Delete a static IP address on the specified interface. See device manual if TCP/IP connection is supported.
            @param[in] ifNum        The interface number: 0 for Ethernet, 1 for wi-fi.
            @param[in] addressIndex The index of the address to be deleted.
            """

            err_cp = (c_long * 1)(0)

            self.device.oceandirect.odapi_adv_ipv4_delete_static_ip_address(self.device.device_id, err_cp, c_ubyte(ifNum), c_ubyte(addressIndex))
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_delete_static_ip_address")
                raise OceanDirectError(err_cp[0], error_msg)

        def ipv4_set_default_gateway_ip_address(self, ifNum: int, ipAddress: list[int]) -> None:
            """!
            Set the default gateway IP address to the specified interface. See device manual if TCP/IP connection is supported.

            @param[in] ifNum        The interface number: 0 for Ethernet, 1 for wi-fi.
            @param[in] addressIndex The index of the address to be deleted.
            @param[in] ipAddress The static IP address to be added. This is 4-byte array data.
            """

            err_cp = (c_long * 1)(0)

            if len(ipAddress) != 4:
                error_msg = "ipv4_set_default_gateway_ip_address() error:  ipAddress must be an array of 4 bytes long."
                raise OceanDirectError(err_cp[0], error_msg)

            ip_address_cp = (c_ubyte * 4)(0)
            for i in range(4):
                ip_address_cp[i] = ipAddress[i]


            self.device.oceandirect.odapi_adv_ipv4_set_default_gateway_ip_address(self.device.device_id, err_cp, c_ubyte(ifNum), ip_address_cp, 4)
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_set_default_gateway_ip_address")
                raise OceanDirectError(err_cp[0], error_msg)

        def ipv4_get_default_gateway_ip_address(self, ifNum: int) -> list[int]:
            """!
            Get the default gateway IP address to the specified interface. See device manual if TCP/IP connection is supported.

            @param[in]  ifNum   The network interface. 0 for ethernet, 1 for wifi.
            @return The ip address (4-byte).
            """
            err_cp        = (c_long * 1)(0)
            ip_address_cp = (c_ubyte * 4)(0)
            self.device.oceandirect.odapi_adv_ipv4_get_default_gateway_ip_address(self.device.device_id, err_cp, c_ubyte(ifNum),
                                                                                  ip_address_cp, 4)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "ipv4_get_default_gateway_ip_address")
                raise OceanDirectError(err_cp[0], error_msg)

            outIpAddress = []
            for i in range(len(ip_address_cp)):
                outIpAddress.append(int(ip_address_cp[i]))
            return outIpAddress

        def get_gpio_pin_count(self) -> int:
            """!
            Get GPIO pin count.
            @return The pin count.
            """

            err_cp = (c_long * 1)(0)
            gpioPinCount = self.device.oceandirect.odapi_adv_get_gpio_pin_count(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_gpio_pin_count")
                raise OceanDirectError(err_cp[0], error_msg)

            return gpioPinCount

        def gpio_set_output_enable1(self, bit: int, isOutput: bool) -> None:
            """!
            Sets the GPIO bit direction to either output or input.
            @param[in] bit      The bit position.
            @param[in] isOutput The bit value which could be true(output) or false(input).
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_gpio_set_output_enable1(self.device.device_id, err_cp, bit, isOutput)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_set_output_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def gpio_get_output_enable1(self, bit: int) -> bool:
            """!
            Get GPIO bit direction.
            @param[in] bit The bit position.
            @return The bit direction which could be True(out) or False(in)
            """

            err_cp = (c_long * 1)(0)
            bitDirection = self.device.oceandirect.odapi_adv_gpio_get_output_enable1(self.device.device_id, err_cp, bit)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_get_output_enable")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(bitDirection))

        def gpio_set_output_enable2(self, bitmask: int) -> None:
            """!
            Set the direction (input/output) of the GPIO pins.
            @param[in] bitmask  The bit mask specifying the pin directions i.e. the nth bit set to 1 sets the nth pin to output.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_gpio_set_output_enable2(self.device.device_id, err_cp, c_int(bitmask))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_set_output_enable2")
                raise OceanDirectError(err_cp[0], error_msg)

        def gpio_get_output_enable2(self) -> int:
            """!
            Get all GPIO bit direction.
            @return All bit (int) direction where each bit could be True(out) or False(in).
            """

            err_cp = (c_long * 1)(0)
            allBitDirection = self.device.oceandirect.odapi_adv_gpio_get_output_enable2(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_get_output_enable2")
                raise OceanDirectError(err_cp[0], error_msg)

            return allBitDirection

        def gpio_set_value1(self, bit: int, isHigh: bool) -> None:
            """!
            Sets the GPIO bit value to either high or low.
            @param[in] bit    The bit position.
            @param[in] isHigh The bit value which could be true(high) or false(low).
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_gpio_set_value1(self.device.device_id, err_cp, bit, isHigh)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_set_value")
                raise OceanDirectError(err_cp[0], error_msg)

        def gpio_get_value1(self, bit: int) -> bool:
            """!
            Get the GPIO bit value in whether it's high(true) or low(false).
            @param[in] bit The bit position.
            @return The bit value. True for high and False for low.
            """

            err_cp = (c_long * 1)(0)
            bitValue = self.device.oceandirect.odapi_adv_gpio_get_value1(self.device.device_id, err_cp, bit)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_get_value")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(bitValue))

        def gpio_set_value2(self, bitmask: int) -> None:
            """!
            Set the logic value for all GPIO pins.
            @param[in] bitmask  The bit mask specifying the logic level of each GPIO pin.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_gpio_set_value2(self.device.device_id, err_cp, c_int(bitmask))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_set_value2")
                raise OceanDirectError(err_cp[0], error_msg)

        def gpio_get_value2(self) -> int:
            """!
            Get all GPIO bit values.
            @return All bit value (int) where each bit could be True(high) or False(low).
            """

            err_cp = (c_long * 1)(0)
            allBitValue = self.device.oceandirect.odapi_adv_gpio_get_value2(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_get_value2")
                raise OceanDirectError(err_cp[0], error_msg)

            return allBitValue

        def gpio_set_output_alternate1(self, bit: int, isAlternate: bool) -> None:
            """!
            Set the alternate functionality for the specified pins (bits). Not
            all spectrometers support this functionality.
            @deprecated This function is deprecated starting with release 2.1 and will be removed in the future release.
            @param[in] bit The GPIO bit or pin to set.
            @param[in] isAlternate Set true to enable the alternate functionality for the pin, false otherwise (pin is a GPIO pin).
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_gpio_set_output_alternate1(self.device.device_id, err_cp, bit, isAlternate)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_set_output_alternate1")
                raise OceanDirectError(err_cp[0], error_msg)

        def gpio_set_output_alternate2(self, bitmask: int) -> None:
            """!
            Set the alternate functionality for the specified pins (bits). Not
            all spectrometers support this functionality.
            @deprecated This function is deprecated starting with release 2.1 and will be removed in the future release.
            @param[in] bitmask  The bits set to 1 to set enable the alternate functionality, 0 otherwise (pin is a GPIO pin).
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_gpio_set_output_alternate2(self.device.device_id, err_cp, c_int(bitmask))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_set_output_alternate2")
                raise OceanDirectError(err_cp[0], error_msg)

        def gpio_get_output_alternate1(self, bit: int) -> bool:
            """!
            Get the setting for alternate functionality on the specified bit (pin). Not
            all spectrometers support this functionality.
            @deprecated This function is deprecated starting with release 2.1 and will be removed in the future release.
            @param[in] bit The GPIO bit or pin to set.
            @return The bit value. True if the pin is set to alternate functionality, false otherwise (pin is a GPIO pin).
            """

            err_cp = (c_long * 1)(0)
            bitValue = self.device.oceandirect.odapi_adv_gpio_get_output_alternate1(self.device.device_id, err_cp, bit)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_get_output_alternate1")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(bitValue))

        def gpio_get_output_alternate2(self) -> int:
            """!
            Get the settings for alternate functionality on the GPIO pins. Not
            all spectrometers support this functionality.
            @deprecated This function is deprecated starting with release 2.1 and will be removed in the future release.
            @return A bitmask with value 1 where the corresponding pin is set to alternate functionality, 0 otherwise (pin is a GPIO pin).
            """

            err_cp = (c_long * 1)(0)
            allBitValue = self.device.oceandirect.odapi_adv_gpio_get_output_alternate2(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "gpio_get_output_alternate2")
                raise OceanDirectError(err_cp[0], error_msg)

            return allBitValue

        def set_led_enable(self, isEnabled: bool) -> None:
            """!
            Enable or disable device LED. If the device don't have an LED then an exception will be thrown.
            @param[in] isEnabled True to enable LED blinking otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_led_enable(self.device.device_id, err_cp, isEnabled)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_led_enable")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_led_enable(self) -> bool:
            """!
            Get device LED state. If the device don't have an LED then an exception will be thrown.
            @return True if LED is enabled otherwise it's False.
            """

            err_cp = (c_long * 1)(0)
            ledState = self.device.oceandirect.odapi_adv_get_led_enable(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_led_enable")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(ledState))

        def get_device_original_vid(self) -> int:
            """!
            Get the original vendor id (VID) of the device.
            @return The VID.
            """

            err_cp   = (c_long * 1)(0)
            orig_vid = self.device.oceandirect.odapi_adv_get_device_original_vid(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_original_vid")
                raise OceanDirectError(err_cp[0], error_msg)

            return orig_vid

        def get_device_original_pid(self) -> int:
            """!
            Get the original product id (PID) of the device.
            @return The PID.
            """

            err_cp   = (c_long * 1)(0)
            orig_pid = self.device.oceandirect.odapi_adv_get_device_original_pid(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_original_pid")
                raise OceanDirectError(err_cp[0], error_msg)

            return orig_pid

        def get_device_vid(self) -> int:
            """!
            Get the current vendor id (VID) of the device.
            @return The VID.
            """

            err_cp = (c_long * 1)(0)
            vid    = self.device.oceandirect.odapi_adv_get_device_vid(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_vid")
                raise OceanDirectError(err_cp[0], error_msg)

            return vid

        def get_device_pid(self) -> int:
            """!
            Get the current product id (PID) of the device.
            @return The PID.
            """

            err_cp = (c_long * 1)(0)
            pid    = self.device.oceandirect.odapi_adv_get_device_pid(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_pid")
                raise OceanDirectError(err_cp[0], error_msg)

            return pid

        def get_device_original_manufacturer_string(self) -> str:
            """!
            Get the original manufacturer string of the device.
            @return The manufacturer string.
            """

            orig_manufacturer = create_string_buffer(b'\000'*50)
            err_cp            = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_get_device_original_manufacturer_string(self.device.device_id, err_cp, orig_manufacturer, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_original_manufacturer_string")
                raise OceanDirectError(err_cp[0], error_msg)

            return orig_manufacturer.value.decode()

        def get_device_original_model_string(self) -> str:
            """!
            Get the original model string of the device.
            @return The model string.
            """

            orig_model = create_string_buffer(b'\000'*50)
            err_cp     = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_get_device_original_model_string(self.device.device_id, err_cp, orig_model, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_original_model_string")
                raise OceanDirectError(err_cp[0], error_msg)

            return orig_model.value.decode()

        def get_device_manufacturer_string(self) -> str:
            """!
            Get the current manufacturer string of the device.
            @return The manufacturer string.
            """

            manufacturer = create_string_buffer(b'\000'*50)
            err_cp       = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_get_device_manufacturer_string(self.device.device_id, err_cp, manufacturer, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_manufacturer_string")
                raise OceanDirectError(err_cp[0], error_msg)

            return manufacturer.value.decode()

        def get_device_model_string(self) -> str:
            """!
            Get the current model string of the device.
            @return The model string.
            """

            model  = create_string_buffer(b'\000'*50)
            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_get_device_model_string(self.device.device_id, err_cp, model, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_original_model_string")
                raise OceanDirectError(err_cp[0], error_msg)

            return model.value.decode()

        def set_device_manufacturer_string(self, manufacturer: str) -> None:
            """!
            Set the current manufacturer string of the device.
            @param[in] manufacturer The new manufacturer string.
            """

            if not manufacturer:
                manufacturer = " "

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_device_manufacturer_string(self.device.device_id, err_cp, manufacturer.encode('utf-8'), len(manufacturer))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_device_manufacturer_string")
                raise OceanDirectError(err_cp[0], error_msg)

        def set_device_model_string(self, model: str) -> None:
            """!
            Set the current model string of the device.
            @param[in] model The new model string.
            """

            if not model:
                model = " "

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_device_model_string(self.device.device_id, err_cp, model.encode('utf-8'), len(model))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_device_model_string")
                raise OceanDirectError(err_cp[0], error_msg)

        # def set_device_vid(self, vid: int) -> None:
        #     """!
        #     Sets the vendor id (VID) of the device.
        #
        #     NOTE:
        #     Use with caution. If the current version of OceanDirect don't have support for the new VID/PID then the
        #     device will not be recognized.
        #
        #     @param[in] vid The device VID.
        #     """
        #
        #     err_cp    = (c_long * 1)(0)
        #     error_msg = self.device.oceandirect.odapi_adv_set_device_vid(self.device.device_id, err_cp, c_int(vid))
        #
        #     if err_cp[0] != 0:
        #         error_msg = self.device.decode_error(err_cp[0],"set_device_vid")
        #         raise OceanDirectError(err_cp[0], error_msg)
        #
        # def set_device_pid(self, pid: int) -> None:
        #     """!
        #     Sets the product id (PID) of the device.
        #
        #     NOTE:
        #     Use with caution. If the current version of OceanDirect don't have support for the new VID/PID then the
        #     device will not be recognized.
        #
        #     @param[in] pid The device PID.
        #     """
        #
        #     err_cp    = (c_long * 1)(0)
        #     error_msg = self.device.oceandirect.odapi_adv_set_device_pid(self.device.device_id, err_cp, c_int(pid))
        #
        #     if err_cp[0] != 0:
        #         error_msg = self.device.decode_error(err_cp[0],"set_device_pid")
        #         raise OceanDirectError(err_cp[0], error_msg)

        def get_device_alias(self) -> str:
            """!
            Read the device alias from the device. If this field in the device is not yet populated then a non-zero(6) code will be returned.
            @return The device alias.
            """

            device_alias  = create_string_buffer(b'\000'*50)
            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_get_device_alias(self.device.device_id, err_cp, device_alias, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_device_alias")
                raise OceanDirectError(err_cp[0], error_msg)

            return device_alias.value.decode()

        def set_device_alias(self, deviceAlias: str) -> None:
            """!
            Set a new device alias to the device.
            @param[in] deviceAlias The device alias. If value is empty then an exception will be thrown.
            """

            if not deviceAlias:
                #15 is an error code defined in OceanDirectAPIConstants.c
                error_msg = self.device.decode_error(15, "set_device_alias")
                raise OceanDirectError(15, error_msg)

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_device_alias(self.device.device_id, err_cp, deviceAlias.encode('utf-8'), len(deviceAlias))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"set_device_alias")
                raise OceanDirectError(err_cp[0], error_msg)

        def reset_device(self) -> None:
            """!
            Restarts the device.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_reset_device(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"reset_device")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_user_string(self) -> str:
            """!
            Read the user string from the device. If this field in the device is not yet populated then a
            non-zero(6) code will be returned. This is the command supported for the newer OBP2.0 enabled devices.
            @return The user string.
            """

            user_string  = create_string_buffer(b'\000'*50)
            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_get_user_string(self.device.device_id, err_cp, user_string, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_user_string")
                raise OceanDirectError(err_cp[0], error_msg)

            return user_string.value.decode()

        def set_user_string(self, userString: str) -> None:
            """!
            Set a new user string to the device. The maximum string length is 16.  This is the command supported
            for the newer OBP2.0 enabled devices.
            @param[in] userString The user string. If value is empty then an exception will be thrown.
            """

            if not userString:
                #15 is an error code defined in OceanDirectAPIConstants.c
                error_msg = self.device.decode_error(15, "set_user_string")
                raise OceanDirectError(15, error_msg)

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_set_user_string(self.device.device_id, err_cp, userString.encode('utf-8'), len(userString))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"set_user_string")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_user_string_count2(self) -> int:
            """!
            Read the total user string count from the device. If the device don't support this command
            then a non-zero error code will be returned. This command is used by legacy devices.
            @return The string count.
            """

            err_cp = (c_long * 1)(0)
            string_count = self.device.oceandirect.odapi_get_user_string_count1(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_user_string_count")
                raise OceanDirectError(err_cp[0], error_msg)

            return string_count

        def get_user_string2(self, index: int) -> str:
            """!
            Read the user string from the device. If this field in the device is not yet populated then a
            non-zero(6) code will be returned. If the device don't support this command then a non-zero
            error code will be returned. This command is used by legacy devices.
            @return The user string.
            """

            user_string = create_string_buffer(b'\000'*50)
            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_get_user_string1(self.device.device_id, err_cp, c_int(index), user_string, 50)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_user_string2")
                raise OceanDirectError(err_cp[0], error_msg)

            return user_string.value.decode()

        def set_user_string2(self, index: int, userString: str) -> None:
            """!
            Write the user string to the device. The maximum string length is 16. If the device don't support this command
            then a non-zero error code will be returned. This command is used by legacy devices.
            @param[in] index The user string index. If index is less than 0 then an exception will be thrown.
            @param[in] userString The user string. If value is empty then an exception will be thrown.
            """

            if index < 0 or not userString:
                #15 is an error code defined in OceanDirectAPIConstants.c
                error_msg = self.device.decode_error(15, "set_user_string")
                raise OceanDirectError(15, error_msg)

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_set_user_string1(self.device.device_id, err_cp, c_int(index), userString.encode('utf-8'), len(userString))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"set_user_string2")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_autonull_maximum_adc_count(self) -> int:
            """!
            Read the maximum ADC counts.
            @return The ADC counts.
            """

            err_cp   = (c_long * 1)(0)
            adcCount = self.device.oceandirect.odapi_adv_get_autonull_maximum_adc_count(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_autonull_maximum_adc_count")
                raise OceanDirectError(err_cp[0], error_msg)

            return adcCount


        def get_autonull_baseline_level(self) -> int:
            """!
            Read the baseline level.
            @return The baseline level.
            """

            err_cp = (c_long * 1)(0)
            baseline = self.device.oceandirect.odapi_adv_get_autonull_baseline_level(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_autonull_baseline_level")
                raise OceanDirectError(err_cp[0], error_msg)

            return baseline

        def get_autonull_saturation_level(self) -> int:
            """!
            Read the saturation level. Most devices returns 65535.
            @return The saturation level.
            """

            err_cp = (c_long * 1)(0)
            saturation = self.device.oceandirect.odapi_adv_get_autonull_saturation_level(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_autonull_saturation_level")
                raise OceanDirectError(err_cp[0], error_msg)

            return saturation

        def get_baud_rate(self) -> int:
            """!
            Read the device RS-232 baud rate. Not all devices supported this command.
            @return The baud rate.
            """

            err_cp = (c_long * 1)(0)
            baud_rate = self.device.oceandirect.odapi_adv_get_baud_rate(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_baud_rate")
                raise OceanDirectError(err_cp[0], error_msg)

            return baud_rate

        def set_baud_rate(self, baudRate: int) -> None:
            """!
            Set a new baud rate for the RS-232 port. Not all devices supported this command.
            @param[in] baudRate The baud rate value.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_set_baud_rate(self.device.device_id, err_cp, c_int(baudRate))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_baud_rate")
                raise OceanDirectError(err_cp[0], error_msg)

        def save_settings_to_flash(self) -> None:
            """!
            Save settings to flash. Not all devices supported this command.
            """

            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_save_settings_to_flash(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "save_settings_to_flash")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_active_pixel_range(self) -> list[int]:
            """!
            Read the active pixel range from the sensor pixel array. This command is being used in OBP-2.0 enabled devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return A list of active pixel range.
            """

            range  = (c_int * 10)(0)
            err_cp = (c_long * 1)(0)
            elementCopied = self.device.oceandirect.odapi_get_active_pixel_range(self.device.device_id, err_cp, range, 10)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_active_pixel_range")
                raise OceanDirectError(err_cp[0], error_msg)

            return list(range)[0:elementCopied]

        def get_optical_dark_pixel_range(self) -> list[int]:
            """!
            Read the optical dark pixel range from the sensor pixel array. This command is being used in OBP-2.0 enabled devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return A list of optical dark pixel range.
            """

            range  = (c_int * 10)(0)
            err_cp = (c_long * 1)(0)
            elementCopied = self.device.oceandirect.odapi_get_optical_dark_pixel_range(self.device.device_id, err_cp, range, 10)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_optical_dark_pixel_range")
                raise OceanDirectError(err_cp[0], error_msg)

            return list(range)[0:elementCopied]

        def get_transition_pixel_range(self) -> list[int]:
            """!
            Read the transition pixel range from the sensor pixel array. This command is being used in OBP-2.0 enabled devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return A list of transition pixel range.
            """

            range  = (c_int * 10)(0)
            err_cp = (c_long * 1)(0)
            elementCopied = self.device.oceandirect.odapi_get_transition_pixel_range(self.device.device_id, err_cp, range, 10)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_transition_pixel_range")
                raise OceanDirectError(err_cp[0], error_msg)

            return list(range)[0:elementCopied]

        def get_bad_pixel_indices(self) -> list[int]:
            """!
            Read bad pixel indices from the sensor pixel array. This command is being used in OBP-2.0 enabled devices.
            If the device don't support this command then a non-zero error code will be returned.
            @return A list of bad pixel indices.
            """

            range  = (c_int * 40)(0)
            err_cp = (c_long * 1)(0)
            elementCopied = self.device.oceandirect.odapi_get_bad_pixel_indices(self.device.device_id, err_cp, range, 40)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0],"get_bad_pixel_indices")
                raise OceanDirectError(err_cp[0], error_msg)

            return list(range)[0:elementCopied]

        def get_network_interface_count(self) -> int:
            """!
            Read the number of supported communication interface.
            @return The number of interface.
            """
            err_cp = (c_long * 1)(0)
            if_count = self.device.oceandirect.odapi_adv_network_conf_get_interface_count(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_network_interface_count")
                raise OceanDirectError(err_cp[0], error_msg)

            return if_count

        def get_network_interface_type(self, interfaceIndex: int) -> int:
            """!
            Return the interface type of the given interface index.
            @param interfaceIndex[in] The interface to look at.
            @return The interface type which could be one 0(Loopback), 1(wired ethernet), 2 (WIFI), and 3 (USB - CDC Ethernet). 
            """
            err_cp = (c_long * 1)(0)
            if_type = self.device.oceandirect.odapi_adv_network_conf_get_interface_type(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_network_interface_type")
                raise OceanDirectError(err_cp[0], error_msg)

            return if_type

        def get_network_interface_status(self, interfaceIndex: int) -> bool:
            """!
            Return true if the interface is enabled otherwise it's false.
            @param interfaceIndex[in] The interface to look at.
            @return True if the interface if enabled otherwise it's False.
            """
            err_cp = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_network_conf_get_interface_status(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_network_interface_status")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(enabled))

        def set_network_interface_status(self, interfaceIndex: int, enable: bool) -> None:
            """!
            Enable or disable the interface.
            
            @param interfaceIndex[in] The interface that will be enabled or disabled.
            @param enable[in] True will enable the interface. False will disable it.
            """
            err_cp = (c_long * 1)(0)

            if enable:
                self.device.oceandirect.odapi_adv_network_conf_set_interface_status(self.device.device_id, err_cp, c_uint(interfaceIndex), c_ubyte(1))
            else:
                self.device.oceandirect.odapi_adv_network_conf_set_interface_status(self.device.device_id, err_cp, c_uint(interfaceIndex), c_ubyte(0))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_network_interface_status")
                raise OceanDirectError(err_cp[0], error_msg)

        def save_network_interface_setting(self, interfaceIndex: int) -> None:
            """!
            Save the network interface settings to the device.
            
            @param interfaceIndex[in] The interface to saved to.
            """
            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_network_conf_save_interface_setting(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "save_network_interface_setting")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_ethernet_gigabit_enable_status(self, interfaceIndex: int) -> bool:
            """!
            Return the status on whether the gigabit ethernet is enabled or not.
            
            @param interfaceIndex[in] The ethernet interface to look at.
            @return The interface status.
            """
            err_cp = (c_long * 1)(0)
            status = self.device.oceandirect.odapi_adv_ethernet_get_gigabit_enable_status(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_ethernet_gigabit_enable_status")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(status)
 
        def set_ethernet_gigabit_enable_status(self, interfaceIndex: int, enable: bool) -> None:
            """!
            Enable or disable the gigabit ethernet the status.
            @param interfaceIndex[in] The ethernet interface to look at.
            @param enable True will enable gigabit ethernet.
            """
            err_cp = (c_long * 1)(0)
            if enable:
                self.device.oceandirect.odapi_adv_ethernet_set_gigabit_enable_status(self.device.device_id, err_cp, c_uint(interfaceIndex), 1)
            else:
                self.device.oceandirect.odapi_adv_ethernet_set_gigabit_enable_status(self.device.device_id, err_cp, c_uint(interfaceIndex), 0)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_ethernet_gigabit_enable_status")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_ethernet_mac_address(self, interfaceIndex: int) -> list[int]:
            """!
            Read the ethernet 6-byte mac address from the spectrometer.
            
            @param interfaceIndex[in] The ethernet interface to look at.
            @return The mac address.
            """
            err_cp         = (c_long * 1)(0)
            array_len      = 6
            mac_address_cp = (c_ubyte * array_len)(0)

            self.device.oceandirect.odapi_adv_ethernet_get_mac_address(self.device.device_id, err_cp, c_uint(interfaceIndex), mac_address_cp, array_len)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_ethernet_mac_address")
                raise OceanDirectError(err_cp[0], error_msg)

            value = []
            for i in range(array_len):
                value.append(int(mac_address_cp[i]))
            return value

        def set_ethernet_mac_address(self, interfaceIndex: int, macAddress: list[int]) -> None:
            """!
            Writes a new ethernet 6-byte mac address into the spectrometer.
            @param interfaceIndex[in] The ethernet interface to look at.
            @param macAddress[in] The new mac address which is 6-byte long.
            """

            err_cp    = (c_long * 1)(0)
            array_len = len(macAddress)

            if array_len != 6:
                error_msg = "set_ethernet_mac_address() error:  macAddress must be an array of 6 bytes long."
                raise OceanDirectError(err_cp[0], error_msg)

            mac_address_cp = (c_ubyte * array_len)(0)
            for i in range(array_len):
                mac_address_cp[i] = macAddress[i]

            self.device.oceandirect.odapi_adv_ethernet_set_mac_address(self.device.device_id, err_cp, c_uint(interfaceIndex), mac_address_cp, array_len)
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_ethernet_mac_address")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_network_interface_count(self) -> int:
            """!
            Read the number of supported communication interface.

            @return The number of interface.
            """
            err_cp = (c_long * 1)(0)
            if_count = self.device.oceandirect.odapi_adv_network_conf_get_interface_count(self.device.device_id, err_cp)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_network_interface_count")
                raise OceanDirectError(err_cp[0], error_msg)

            return if_count

        def get_network_interface_type(self, interfaceIndex: int) -> int:
            """!
            Return the interface type of the given interface index.

            @param interfaceIndex[in] The interface to look at.
            @return The interface type which could be one 0(Loopback), 1(wired ethernet), 2 (WIFI), and 3 (USB - CDC Ethernet). 
            """
            err_cp = (c_long * 1)(0)
            if_type = self.device.oceandirect.odapi_adv_network_conf_get_interface_type(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_network_interface_type")
                raise OceanDirectError(err_cp[0], error_msg)

            return if_type

        def get_network_interface_status(self, interfaceIndex: int) -> bool:
            """!
            Return true if the interface is enabled otherwise it's false.

            @param interfaceIndex[in] The interface to look at.
            @return True if the interface if enabled otherwise it's False.
            """
            err_cp = (c_long * 1)(0)
            enabled = self.device.oceandirect.odapi_adv_network_conf_get_interface_status(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_network_interface_status")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(c_ubyte(enabled))

        def set_network_interface_status(self, interfaceIndex: int, enable: bool) -> None:
            """!
            Enable or disable the interface.
            
            @param interfaceIndex[in] The interface that will be enabled or disabled.
            @param enable[in] True will enable the interface. False will disable it.
            """
            err_cp = (c_long * 1)(0)

            if enable:
                self.device.oceandirect.odapi_adv_network_conf_set_interface_status(self.device.device_id, err_cp, c_uint(interfaceIndex), c_ubyte(1))
            else:
                self.device.oceandirect.odapi_adv_network_conf_set_interface_status(self.device.device_id, err_cp, c_uint(interfaceIndex), c_ubyte(0))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_network_interface_status")
                raise OceanDirectError(err_cp[0], error_msg)

        def save_network_interface_setting(self, interfaceIndex: int) -> None:
            """!
            Save the network interface settings to the device.
            
            @param interfaceIndex[in] The interface to saved to.
            """
            err_cp = (c_long * 1)(0)
            self.device.oceandirect.odapi_adv_network_conf_save_interface_setting(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "save_network_interface_setting")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_ethernet_gigabit_enable_status(self, interfaceIndex: int) -> bool:
            """!
            Return the status on whether the gigabit ethernet is enabled or not.
            
            @param interfaceIndex[in] The ethernet interface to look at.
            @return The interface status.
            """
            err_cp = (c_long * 1)(0)
            status = self.device.oceandirect.odapi_adv_ethernet_get_gigabit_enable_status(self.device.device_id, err_cp, c_uint(interfaceIndex))

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_ethernet_gigabit_enable_status")
                raise OceanDirectError(err_cp[0], error_msg)

            return bool(status)
 
        def set_ethernet_gigabit_enable_status(self, interfaceIndex: int, enable: bool) -> None:
            """!
            Enable or disable the gigabit ethernet the status.

            @param interfaceIndex[in] The ethernet interface to look at.
            @param enable True will enable gigabit ethernet.
            """
            err_cp = (c_long * 1)(0)
            if enable:
                self.device.oceandirect.odapi_adv_ethernet_set_gigabit_enable_status(self.device.device_id, err_cp, c_uint(interfaceIndex), 1)
            else:
                self.device.oceandirect.odapi_adv_ethernet_set_gigabit_enable_status(self.device.device_id, err_cp, c_uint(interfaceIndex), 0)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_ethernet_gigabit_enable_status")
                raise OceanDirectError(err_cp[0], error_msg)

        def get_ethernet_mac_address(self, interfaceIndex: int) -> list[int]:
            """!
            Read the ethernet 6-byte mac address from the spectrometer.
            
            @param interfaceIndex[in] The ethernet interface to look at.
            @return The mac address.
            """
            err_cp         = (c_long * 1)(0)
            array_len      = 6
            mac_address_cp = (c_ubyte * array_len)(0)

            self.device.oceandirect.odapi_adv_ethernet_get_mac_address(self.device.device_id, err_cp, c_uint(interfaceIndex), mac_address_cp, array_len)

            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "get_ethernet_mac_address")
                raise OceanDirectError(err_cp[0], error_msg)

            value = []
            for i in range(array_len):
                value.append(int(mac_address_cp[i]))
            return value

        def set_ethernet_mac_address(self, interfaceIndex: int, macAddress: list[int]) -> None:
            """!
            Writes a new ethernet 6-byte mac address into the spectrometer.

            @param interfaceIndex[in] The ethernet interface to look at.
            @param macAddress[in] The new mac address which is 6-byte long.
            """

            err_cp    = (c_long * 1)(0)
            array_len = len(macAddress)

            if array_len != 6:
                error_msg = "set_ethernet_mac_address() error:  macAddress must be an array of 6 bytes long."
                raise OceanDirectError(err_cp[0], error_msg)

            mac_address_cp = (c_ubyte * array_len)(0)
            for i in range(array_len):
                mac_address_cp[i] = macAddress[i]

            self.device.oceandirect.odapi_adv_ethernet_set_mac_address(self.device.device_id, err_cp, c_uint(interfaceIndex), mac_address_cp, array_len)
            if err_cp[0] != 0:
                error_msg = self.device.decode_error(err_cp[0], "set_ethernet_mac_address")
                raise OceanDirectError(err_cp[0], error_msg)
